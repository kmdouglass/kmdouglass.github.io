<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (Posts about micro-manager)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link href="http://kmdouglass.github.io/categories/micro-manager.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sun, 16 Jun 2019 08:09:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Linking shared libraries in Micro-Manager for Linux</title><link>http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;Lately I have been working on a new &lt;a class="reference external" href="https://github.com/kmdouglass/RPi-DeviceAdapters"&gt;Video4Linux2 device adapter&lt;/a&gt; for &lt;a class="reference external" href="https://micro-manager.org/"&gt;Micro-Manager&lt;/a&gt;. I
encountered the following error after adding some functionality that introduced two &lt;a class="reference external" href="https://www.boost.org/"&gt;Boost
libraries&lt;/a&gt; as new dependencies in my project.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-1"&gt;&lt;/a&gt;Traceback &lt;span class="o"&gt;(&lt;/span&gt;most recent call last&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-2"&gt;&lt;/a&gt;  File &lt;span class="s2"&gt;"RPiV4L2.py"&lt;/span&gt;, line &lt;span class="m"&gt;17&lt;/span&gt;, in &amp;lt;module&amp;gt;
&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-3"&gt;&lt;/a&gt;    mmc.loadDevice&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"camera"&lt;/span&gt;, &lt;span class="s2"&gt;"RPiV4L2"&lt;/span&gt;, &lt;span class="s2"&gt;"RPiV4L2"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-4"&gt;&lt;/a&gt;  File &lt;span class="s2"&gt;"/home/micro-manager/app/lib/micro-manager/MMCorePy.py"&lt;/span&gt;, line &lt;span class="m"&gt;3515&lt;/span&gt;, in loadDevice
&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; _MMCorePy.CMMCore_loadDevice&lt;span class="o"&gt;(&lt;/span&gt;self, label, moduleName, deviceName&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_02df986928d44e26886a11efd12ce341-6"&gt;&lt;/a&gt;MMCorePy.CMMError: Failed to load device &lt;span class="s2"&gt;"RPiV4L2"&lt;/span&gt; from adapter module &lt;span class="s2"&gt;"RPiV4L2"&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; Failed to load device adapter &lt;span class="s2"&gt;"RPiV4L2"&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; Failed to load module &lt;span class="s2"&gt;"/home/micro-manager/app/lib/micro-manager/libmmgr_dal_RPiV4L2.so.0"&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; /home/micro-manager/app/lib/micro-manager/libmmgr_dal_RPiV4L2.so.0: undefined symbol: _ZN5boost10filesystem6detail13dir_itr_closeERPvS3_ &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;I received this error when I tried to load the device in a Python script. At first I was puzzled
because the code compiled without problems, but I soon found that the solution was simple.&lt;/p&gt;
&lt;p&gt;The key part of the message is &lt;tt class="docutils literal"&gt;undefined symbol:
_ZN5boost10filesystem6detail13dir_itr_closeERPvS3_&lt;/tt&gt;. To troubleshoot this, I first demangled the
symbol name by entering it at &lt;a class="reference external" href="https://demangler.com/"&gt;https://demangler.com/&lt;/a&gt;. I discovered that the symbol was referring to
the function &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::filesystem::detail::dir_itr_close(void*&amp;amp;,&lt;/span&gt; &lt;span class="pre"&gt;void*&amp;amp;)&lt;/span&gt;&lt;/tt&gt;. I had added both the
Boost filesystem and Boost regex libraries to this device adapter as dependencies, so it was not
surprising that either of their names appeared in the error message.&lt;/p&gt;
&lt;p&gt;Next, I used the &lt;a class="reference external" href="http://man7.org/linux/man-pages/man1/ldd.1.html"&gt;ldd&lt;/a&gt; program to check which libraries my device adapter were linked
against. (libmmgr_dal_RPiV4l2.so.0 is the name of the device adapter library file).&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-1"&gt;&lt;/a&gt;$ ldd libmmgr_dal_RPiV4L2.so.0
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-2"&gt;&lt;/a&gt;     linux-vdso.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0x7ec21000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-3"&gt;&lt;/a&gt;     libdl.so.2 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/libdl.so.2 &lt;span class="o"&gt;(&lt;/span&gt;0x76e9c000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-4"&gt;&lt;/a&gt;     libstdc++.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libstdc++.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0x76d54000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-5"&gt;&lt;/a&gt;     libm.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/libm.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0x76cdc000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-6"&gt;&lt;/a&gt;     libc.so.6 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/libc.so.6 &lt;span class="o"&gt;(&lt;/span&gt;0x76bee000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-7"&gt;&lt;/a&gt;     libgcc_s.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/libgcc_s.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0x76bc1000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-8"&gt;&lt;/a&gt;     libicudata.so.57 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libicudata.so.57 &lt;span class="o"&gt;(&lt;/span&gt;0x75334000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-9"&gt;&lt;/a&gt;     libicui18n.so.57 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libicui18n.so.57 &lt;span class="o"&gt;(&lt;/span&gt;0x75187000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-10"&gt;&lt;/a&gt;     libicuuc.so.57 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libicuuc.so.57 &lt;span class="o"&gt;(&lt;/span&gt;0x7505e000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-11"&gt;&lt;/a&gt;     librt.so.1 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/librt.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0x75048000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-12"&gt;&lt;/a&gt;     libpthread.so.0 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /lib/arm-linux-gnueabihf/libpthread.so.0 &lt;span class="o"&gt;(&lt;/span&gt;0x75024000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_f8dbd5a6b4be4049acdcc6c3b0b209cc-13"&gt;&lt;/a&gt;     /lib/ld-linux-armhf.so.3 &lt;span class="o"&gt;(&lt;/span&gt;0x76fb4000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Neither libboost_filesystem nor libboost_regex are listed, so I knew that they were not linked with
the device adapter.&lt;/p&gt;
&lt;p&gt;There is a Makefile.am included in the directory of every device adapter in the Micro-Manager
project. This file is used by Autotools define how the device adapter should be compiled and
linked. Here is what my Makefile.am looked like:&lt;/p&gt;
&lt;table class="codetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;a href="http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/#rest_code_00c81f3febaa4837baf55d9bec9ab8e9-1"&gt;1&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/#rest_code_00c81f3febaa4837baf55d9bec9ab8e9-2"&gt;2&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/#rest_code_00c81f3febaa4837baf55d9bec9ab8e9-3"&gt;3&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/#rest_code_00c81f3febaa4837baf55d9bec9ab8e9-4"&gt;4&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/#rest_code_00c81f3febaa4837baf55d9bec9ab8e9-5"&gt;5&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre class="code Makefile"&gt;&lt;a name="rest_code_00c81f3febaa4837baf55d9bec9ab8e9-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;AM_CXXFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MMDEVAPI_CXXFLAGS&lt;span class="k"&gt;)&lt;/span&gt;
&lt;a name="rest_code_00c81f3febaa4837baf55d9bec9ab8e9-2"&gt;&lt;/a&gt;&lt;span class="nv"&gt;deviceadapter_LTLIBRARIES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; libmmgr_dal_RPiV4L2.la
&lt;a name="rest_code_00c81f3febaa4837baf55d9bec9ab8e9-3"&gt;&lt;/a&gt;&lt;span class="nv"&gt;libmmgr_dal_RPiV4L2_la_SOURCES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; RPiV4L2.cpp RPiV4L2.h refactor.h ../../MMDevice/MMDevice.h ../../MMDevice/DeviceBase.h
&lt;a name="rest_code_00c81f3febaa4837baf55d9bec9ab8e9-4"&gt;&lt;/a&gt;&lt;span class="nv"&gt;libmmgr_dal_RPiV4L2_la_LIBADD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MMDEVAPI_LIBADD&lt;span class="k"&gt;)&lt;/span&gt;
&lt;a name="rest_code_00c81f3febaa4837baf55d9bec9ab8e9-5"&gt;&lt;/a&gt;&lt;span class="nv"&gt;libmmgr_dal_RPiV4L2_la_LDFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MMDEVAPI_LDFLAGS&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;After experimenting a bit, I discovered that I could instruct the linker to link against shared
libraries by adding them to the &lt;tt class="docutils literal"&gt;libmmgr_dal_RPiV4L2_la_LDFLAGS&lt;/tt&gt; variable with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-l&lt;/span&gt;&lt;/tt&gt;
flag. The resulting line now looks like:&lt;/p&gt;
&lt;pre class="code Makefile"&gt;&lt;a name="rest_code_ca9552344c1245cc91c80ec3737a83d8-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;libmmgr_dal_RPiV4L2_la_LDFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;MMDEVAPI_LDFLAGS&lt;span class="k"&gt;)&lt;/span&gt; -lboost_regex -lboost_filesystem
&lt;/pre&gt;&lt;p&gt;Finally, running &lt;tt class="docutils literal"&gt;ldd&lt;/tt&gt; on the rebuilt device adapter now shows these two libraries:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_6daa273d04d74cfaae49c56c46a05fbf-1"&gt;&lt;/a&gt;$ ldd libmmgr_dal_RPiV4L2.so.0
&lt;a name="rest_code_6daa273d04d74cfaae49c56c46a05fbf-2"&gt;&lt;/a&gt;     linux-vdso.so.1 &lt;span class="o"&gt;(&lt;/span&gt;0x7ed74000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_6daa273d04d74cfaae49c56c46a05fbf-3"&gt;&lt;/a&gt;     libboost_regex.so.1.62.0 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libboost_regex.so.1.62.0 &lt;span class="o"&gt;(&lt;/span&gt;0x76e3c000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_6daa273d04d74cfaae49c56c46a05fbf-4"&gt;&lt;/a&gt;     libboost_filesystem.so.1.62.0 &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; /usr/lib/arm-linux-gnueabihf/libboost_filesystem.so.1.62.0 &lt;span class="o"&gt;(&lt;/span&gt;0x76e1b000&lt;span class="o"&gt;)&lt;/span&gt;
&lt;a name="rest_code_6daa273d04d74cfaae49c56c46a05fbf-5"&gt;&lt;/a&gt;     ...
&lt;/pre&gt;&lt;/div&gt;</description><category>micro-manager</category><guid>http://kmdouglass.github.io/posts/linking-shared-libraries-in-micro-manager-for-linux/</guid><pubDate>Sat, 19 Jan 2019 11:00:37 GMT</pubDate></item><item><title>How I built a cross-compilation workflow for the Raspberry Pi</title><link>http://kmdouglass.github.io/posts/how-i-built-a-cross-compilation-workflow-for-the-raspberry-pi/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;Some of you may know I tinker with the Raspberry Pi in my free time
and that one of my current projects is to build a lensless microscope
with the Pi as the brains. To control the microscope, I decided a
while ago that I would use &lt;a class="reference external" href="https://micro-manager.org/wiki/Micro-Manager"&gt;Micro-Manager&lt;/a&gt;, an open-source
software package for microscope control. I made this decision for a
few reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;I already knew the Micro-Manager codebase since I use it frequently
at work.&lt;/li&gt;
&lt;li&gt;The Micro-Manager core provides a device-independent interface to
hardware.&lt;/li&gt;
&lt;li&gt;I've contributed to the project in the past and feel a sense of
loyalty to the project and the people involved. Expanding
Micro-Manager into embedded microscopy would be a great way for me
to give back to the community.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Building Micro-Manager from source code presents its own set of
challenges. After ensuring that you have the correct build
environment, you need to actually compile it, and here's where things
get tricky in Raspyberry Pi development. The Pi has an ARM processor,
whereas most laptops and workstations use a x86_64 processor. This
means that code compiled on a typical desktop PC will not work on the
Pi. As I showed in &lt;a class="reference external" href="https://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi.html"&gt;my earlier post&lt;/a&gt;,
you can compile the code directly on the Pi to circumvent this, but
this unfortunately is quite cumbersome because the code base and
dependencies are quite large. (They are nearly 8 GB in
total). Furthermore, compiling the project on the Pi is slow and
requires connecting to it via ssh or working directly on a TV screen
or monitor.&lt;/p&gt;
&lt;p&gt;These problems extend beyond Micro-Manager to other large-scale
projects that require code compilation for a specific processor
architecture. In this post, I'll describe the workflow that I
developed for cross-compiling projects for the Raspberry Pi.&lt;/p&gt;
&lt;div class="section" id="previous-attempts"&gt;
&lt;h2&gt;Previous attempts&lt;/h2&gt;
&lt;p&gt;Prior to the workflow that is the main topic of this post, I managed
to cross-compile Micro-Manager using a &lt;cite&gt;chroot&lt;/cite&gt; environment and the
&lt;a class="reference external" href="https://www.qemu.org/"&gt;QEMU emulator&lt;/a&gt;. &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Chroot"&gt;chroot&lt;/a&gt; is a Linux command that
changes the apparent root (or '/') directory for a running
process. With this approach, I mount an image of the &lt;a class="reference external" href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian
operating system&lt;/a&gt;
that contains the gcc and g++ compilers and libraries for the ARM
architecture. Then, I chroot into the image and run a setup script
that builds the software. During execution of this script, the QEMU
static libraries run the ARM compilers from within the chroot
environment to build the project. The compiled code remains inside the
image, which I then burn onto a micro SD card to insert into the Pi. I
uploaded &lt;a class="reference external" href="https://gist.github.com/kmdouglass/38e1383c7e62745f3cf522702c21cb49"&gt;a gist of the bash script&lt;/a&gt;
which orchestrates all this, and my inspiration for this approach came
from a great series of blog posts from &lt;a class="reference external" href="https://disconnected.systems/blog/custom-rpi-image-with-github-travis/"&gt;Disconnected Systems&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately this approach is a huge amount of work. As you can see in
the gist, it's fairly complicated bash scripting that's not easy to
debug. Furthermore, the setup script that is run inside the image
needs to do a lot of work beyond cross-compiling, like setting up the
user, permissions, network, etc. Debugging the final product is also a
challenge because you need to verify that it's working on the Pi,
which requires burning the image to a micro SD card.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cross-compiling-with-docker"&gt;
&lt;h2&gt;Cross-compiling with Docker&lt;/h2&gt;
&lt;p&gt;After a bit of research I decided I would try instead to use &lt;a class="reference external" href="https://www.docker.com/"&gt;Docker&lt;/a&gt; for cross-compilation and deployment to
the Pi. I had just started using Docker at work to build reproducible
environments for scientific computing research. In particular, and
unlike my chroot script, I had learned that a Docker container that
built the project could work on nearly any system that had Docker
installed. Furthermore, deploying updates can be done on any Raspberry
Pi that's running Docker.&lt;/p&gt;
&lt;p&gt;I liked the idea of a portable cross-compilation workflow, so I dove
into the Docker documentation and managed to get everything working in
a few weeks of tinkering at home.&lt;/p&gt;
&lt;div class="section" id="an-overview-of-docker"&gt;
&lt;h3&gt;An overview of Docker&lt;/h3&gt;
&lt;p&gt;You can find many resources online about Docker, so I won't go into
the details here. The main thing you need to know is that Docker is a
system for creating, running, and sharing &lt;em&gt;containers&lt;/em&gt;, which are
something like light weight virtual machines. Containers solve the
problem in software development of how to build and deploy programs
that have a complex set of dependencies. It does this by isolating the
environment in which a program runs from the rest of the operating
system. For example, if you have a computer that has a certain version
of gcc (the GNU C compiler) installed, but your application requires a
different version, then you can install the required gcc along with
your application inside a container and they will not interfere with
the version of gcc that belongs to your operating system. This also
means that you can send your container to any machine that has Docker
installed and it should just run without having to do any setup.&lt;/p&gt;
&lt;p&gt;Other important things to know about Docker are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;There are two main types of objects: images and containers. Images
are sort of like blueprints that define what is inside a container,
whereas containers are like the actual buildings specified by the
blueprints. There can be many containers that come from a single
image.&lt;/li&gt;
&lt;li&gt;Containers are meant to be immutable. When you stop them and restart
them, they always restart in the same state as when they were first
created.&lt;/li&gt;
&lt;li&gt;Since containers are immutable, some of your application data may
need to be placed in a volume, which is either another container or
a folder on the host system. A volume gets connected to your
application container and exists even when your application
container is not running.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-cross-compilation-workflow"&gt;
&lt;h2&gt;The cross-compilation workflow&lt;/h2&gt;
&lt;p&gt;Now that we have established the essential background to this project,
let's look at the cross-compilation workflow. Below is a picture that
provides a sense of the entire process, moving in general from
left-to-right.&lt;/p&gt;
&lt;img alt="The cross-compilation workflow" class="align-center" src="http://kmdouglass.github.io/images/mm_docker_workflow.png"&gt;
&lt;p&gt;The process involves two Docker containers: one for building
Micro-Manager and the other for running the application. The build
dependencies and the QEMU emulator are both located inside the build
container, having been specified when its image was created. These
allow us to compile Micro-Manager for the ARM architecture.  The
source code is connected to the build container as a &lt;em&gt;bind mount&lt;/em&gt;,
which is a folder from the host workstation that is mounted inside the
build container when it is run.&lt;/p&gt;
&lt;p&gt;Once the libraries are compiled, they are installed into a folder
inside the bind mount so that the host system will have access to them
after the build container closes. Next, the compiled libraries are
copied directly into an image that defines the application
container. This image defines only the essential run-time requirements
for running Micro-Manager and nothing else. The application image is
stored on the registry server which I set up on my local network. This
makes it easy for the Raspberry Pi to download the latest image and
run the Micro-Manager application container whenever I make changes.&lt;/p&gt;
&lt;p&gt;An important aspect of this workflow is how the data is passed between
the systems and containers. Unlike what you will find in many
introductory tutorials on Docker, I do not add the Micro-Manager
source code directly to the build image/containers but instead use a
bind mount. The reason for this is that the source code and 3rd party
libraries are quite large, about 8 GB in total. By using a bind mount,
I avoid needless copying of this data. Another reason for using a bind
mount is that the source code will change frequently during
development. If I add the source code to the image, then I will have
to recreate the image every time the source code changes.&lt;/p&gt;
&lt;p&gt;Once the libraries are built, I directly copy them into the
application image because they are much, much smaller than the source
code. I also want the code stored directly in the image so that the
application image is all the Raspberry Pi needs to run the
program. The image is stored in my local &lt;a class="reference external" href="https://docs.docker.com/registry/"&gt;Docker registry&lt;/a&gt; server so that once I push an
updated image to the server, the Raspberry Pi can download it and use
it immediately.&lt;/p&gt;
&lt;div class="section" id="step-0-prerequisites"&gt;
&lt;h3&gt;Step 0: Prerequisites&lt;/h3&gt;
&lt;p&gt;I am going to assume that you already have installed Docker. (If not,
follow &lt;a class="reference external" href="https://docs.docker.com/install/"&gt;these directions&lt;/a&gt;.) I am
also going to assume that you are somewhat familiar with how to work
on a Linux system. The Raspberry Pi runs Linux, so you probably
wouldn't be here if you didn't already know at least a little.&lt;/p&gt;
&lt;p&gt;For this article, I am working with these versions of Docker and
Ubuntu on my host workstation.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~$ uname -a
Linux xxxxx 4.13.0-39-generic #44~16.04.1-Ubuntu SMP Thu Apr 5 16:43:10 UTC 2018 x86_64 x86_64
x86_64 GNU/Linux

kmdouglass@xxxxx:~$ docker version
Client:
 Version:      18.03.1-ce
 API version:  1.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Thu Apr 26 07:17:20 2018
 OS/Arch:      linux/amd64
 Experimental: false
 Orchestrator: swarm

Server:
 Engine:
  Version:      18.03.1-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.5
  Git commit:   9ee9f40
  Built:        Thu Apr 26 07:15:30 2018
  OS/Arch:      linux/amd64
  Experimental: false
&lt;/pre&gt;
&lt;p&gt;Finally, below is how my project directory structure is laid out.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker$ tree -L 2
.
└── rpi-micromanager
    ├── 2.0-python
    │   ├── build
    │   └── Dockerfile
    └── build
        ├── build
        ├── Dockerfile
        ├── run
        └── setup
&lt;/pre&gt;
&lt;p&gt;I have two folders; build, which contains the files for the build
container, and 2.0-python, which contains the files for creating the
Micro-Manager application container. (In my case, I am going to build
the Python wrapper for Micro-Manager 2.0.) Inside each folder are the
scripts and Dockerfiles that execute the various steps of the
workflow.&lt;/p&gt;
&lt;p&gt;The final prerequisite is to register QEMU with the Docker build
agent. First, install a few packages for QEMU. On Ubuntu, this looks
like&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_deacfa1a9a25439a970acfc38f97963f-1"&gt;&lt;/a&gt;$ sudo apt update
&lt;a name="rest_code_deacfa1a9a25439a970acfc38f97963f-2"&gt;&lt;/a&gt;$ sudo install qemu qemu-user-static qemu-user binfmt-support
&lt;/pre&gt;&lt;p&gt;Finally, register the build agent with the command:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_e8b8d4d4c8e540d59c38b8017332baba-1"&gt;&lt;/a&gt;$ docker run --rm --privileged multiarch/qemu-user-static:register --reset
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="step-1-create-the-build-image"&gt;
&lt;h3&gt;Step 1: Create the build image&lt;/h3&gt;
&lt;p&gt;Inside the build folder, I have a file called Dockerfile. Here are its
contents.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Defines a build environment for Micro-Manager on the Raspberry Pi.&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: docker build \&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          -t NAME:TAG \&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#         .&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-10"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-11"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-13"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-start"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Get the build dependencies.&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-16"&gt;&lt;/a&gt;RUN apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get -y install --no-install-recommends &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-17"&gt;&lt;/a&gt;autoconf &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-18"&gt;&lt;/a&gt;automake &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-19"&gt;&lt;/a&gt;build-essential &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-20"&gt;&lt;/a&gt;git &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-21"&gt;&lt;/a&gt;libatlas-base-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-22"&gt;&lt;/a&gt;libboost-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-23"&gt;&lt;/a&gt;libboost-all-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-24"&gt;&lt;/a&gt;libtool &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-25"&gt;&lt;/a&gt;patch &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-26"&gt;&lt;/a&gt;pkg-config &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-27"&gt;&lt;/a&gt;python3-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-28"&gt;&lt;/a&gt;python3-pip &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-29"&gt;&lt;/a&gt;python3-setuptools &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-30"&gt;&lt;/a&gt;python3-wheel &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-31"&gt;&lt;/a&gt;swig &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-32"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/* &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-33"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; pip3 install numpy
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-34"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-35"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-end"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-36"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-37"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Set up the mount point for the source files and setup script.&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-38"&gt;&lt;/a&gt;ADD setup /micro-manager/
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-39"&gt;&lt;/a&gt;VOLUME /micro-manager/src
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-40"&gt;&lt;/a&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-41"&gt;&lt;/a&gt;WORKDIR /micro-manager/src
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-42"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_c0a4d4086a554bd99c3d67b732f508f6-43"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/micro-manager/setup"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;A Dockerfile defines the steps in building an image -- in this case,
the build image. Let's break this file down into pieces. In the first
two lines that follow the comments, I specify that my image is based
on the resin/raspberrypi3-debian:stretch image and that I am the
maintainer.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_6f6100ac8b7b4501961496830d326e59-1"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_6f6100ac8b7b4501961496830d326e59-2"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;/pre&gt;&lt;p&gt;Images from &lt;a class="reference external" href="https://hub.docker.com/u/resin/"&gt;Resin&lt;/a&gt; are freely
available and already have the QEMU emulator installed. Next, I
specify what commands should be run for the ARM architecture. Any
commands located between &lt;tt class="docutils literal"&gt;RUN [ &lt;span class="pre"&gt;"cross-build-start"&lt;/span&gt; ]&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;RUN [
&lt;span class="pre"&gt;"cross-build-end"&lt;/span&gt; ]&lt;/tt&gt; will be run using the emulator. Inside these two
commands, I install the build dependencies for Micro-Manager using
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;apt-get&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pip&lt;/tt&gt;. (These are just standard commands for
installing software on Debian/Ubuntu Linux machines and from PyPI,
respectively.)&lt;/p&gt;
&lt;p&gt;After the installation of the requirements completes, I add the setup
script to the folder /micro-manager inside the image with the &lt;tt class="docutils literal"&gt;ADD
setup &lt;span class="pre"&gt;/micro-manager/&lt;/span&gt;&lt;/tt&gt; command. The setup script contains the
commands that will actually compile Micro-Manager. I then define a
mount point for the source code with &lt;tt class="docutils literal"&gt;VOLUME
&lt;span class="pre"&gt;/micro-manager/src&lt;/span&gt;&lt;/tt&gt;. &lt;strong&gt;It's important to realize here that you do not
mount volumes inside images, you mount volumes inside containers.&lt;/strong&gt;
This command is just telling the image to expect a folder to be
mounted at this location when the container is run.&lt;/p&gt;
&lt;p&gt;The last three lines set the working directory, the entrypoint and the
default container command, respectively.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_562074e3cfad486b82873bea18b77684-1"&gt;&lt;/a&gt;WORKDIR /micro-manager/src
&lt;a name="rest_code_562074e3cfad486b82873bea18b77684-2"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_562074e3cfad486b82873bea18b77684-3"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/micro-manager/setup"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;This specific entrypoint tells Docker that any containers built from
this image should first run Tini, which is a lightweight init system
for Docker containers. If you do not specify Tini as the entry point,
then it will not be able to reap zombies. (I don't know what this
means exactly, but it sounds cool and you can read about it here:
&lt;a class="reference external" href="https://github.com/krallin/tini"&gt;https://github.com/krallin/tini&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;By default, the container will run the setup script, but, since I used
the &lt;tt class="docutils literal"&gt;CMD&lt;/tt&gt; directive, this can be overriden in case we need to
perform some manual steps. Roughly speaking, you can think of the
entrypoint as the command that can not be overridden and the CMD
command as the one that can be. In other words, Tini will always be
executed when containers created from this image are launched, whereas
you can choose not to run the setup script but instead to enter the
container through a Bash shell, for example.&lt;/p&gt;
&lt;p&gt;To build the image, I use the following build script located in the
same directory as the Dockerfile for convenience.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./build&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-6"&gt;&lt;/a&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-7"&gt;&lt;/a&gt;docker build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-8"&gt;&lt;/a&gt;       -t localhost:5000/rpi-micromanager:build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3ac75315a8d942d49bc70301c60b9981-9"&gt;&lt;/a&gt;       .
&lt;/pre&gt;&lt;p&gt;By using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt; &lt;span class="pre"&gt;localhost:5000/rpi-micromanager:build&lt;/span&gt;&lt;/tt&gt; argument I am
giving the image a name of &lt;em&gt;rpi-micromanager&lt;/em&gt;, a tag of &lt;em&gt;build&lt;/em&gt;, and
specifying that I will eventually host this image on my local registry
server (localhost) on port 5000.&lt;/p&gt;
&lt;p&gt;In case you are wondering about the contents of the setup script,
don't worry. I'll explain it in the next section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-2-compile-micro-manager"&gt;
&lt;h3&gt;Step 2: Compile Micro-Manager&lt;/h3&gt;
&lt;p&gt;After the image is built, I create a container and use it to compile
Micro-Manager. For this, I use the run script in the build directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./run DIR CONFIGURE&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# DIR is the parent folder containing the micro-manager Git&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# repository, the 3rdpartypublic Subversion repository, and any&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# additional build resources.&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-9"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-10"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# If CONFIGURE=true, the build system is remade and the configure&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-11"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# script is rerun before running 'make' and 'make install'. If&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-12"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# CONFIGURE=false, only 'make' and 'make install' are run.&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-13"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-14"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# The compiled program files are stored in a bind mount volume so that&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# they may be copied into the deployment container.&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-16"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-17"&gt;&lt;/a&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-18"&gt;&lt;/a&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-19"&gt;&lt;/a&gt;&lt;span class="nv"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/micro-manager/setup &lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-20"&gt;&lt;/a&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-21"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Remove the build artifacts from previous builds.&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-22"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-23"&gt;&lt;/a&gt;    rm -rf &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/build &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-24"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-25"&gt;&lt;/a&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-26"&gt;&lt;/a&gt;docker run --rm &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-27"&gt;&lt;/a&gt;       -v &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;:/micro-manager/src &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-28"&gt;&lt;/a&gt;       --name mm-build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-29"&gt;&lt;/a&gt;       localhost:5000/rpi-micromanager:build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_9aac600ac9774ed1b1899fa4c2e3c8fb-30"&gt;&lt;/a&gt;       &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;cmd&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The script takes two arguments. The first is the path to the folder
containing all the source code (see below for details). The second
argument is either &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. (It can actually be
anything, but it will only compile Micro-Manager if either &lt;strong&gt;true&lt;/strong&gt; or
&lt;strong&gt;false&lt;/strong&gt; are provided.) If true, the full build process is run,
including setting up the configure script; if false, only make and
make install are run, which should recompile and install only recently
updated files.&lt;/p&gt;
&lt;p&gt;The run script uses the -v argument to &lt;tt class="docutils literal"&gt;docker run&lt;/tt&gt; to mount the
source directory into the container at the point specified by the
&lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt; command in the Dockerfile. The directory layout on my host
file system for the source directory looks like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:/media/kmdouglass/Data/micro-manager$ tree -L 1
.
├── 3rdpartypublic
├── micro-manager
└── patches
&lt;/pre&gt;
&lt;p&gt;The patches folder is not necessary and only there to fix &lt;a class="reference external" href="https://github.com/micro-manager/micro-manager/pull/613"&gt;a bug&lt;/a&gt; in the
WieneckeSinscke device adapter. (This bug may be fixed by now.)
3rdpartypublic is the large Subversion repository of all the required
software to build Micro-Manager, and micro-manager is the &lt;a class="reference external" href="https://github.com/micro-manager/micro-manager"&gt;cloned
GitHub repository&lt;/a&gt;. Prior to building,
I checkout the mm2 branch because I am interested in developing my
application for Micro-Manager 2.0.&lt;/p&gt;
&lt;p&gt;The setup script that is run inside the container and mentioned in the
previous section looks like this.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# # Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Builds Micro-Manager.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./setup CONFIGURE&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-9"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# If CONFIGURE=true, the build system is remade and the configure&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-10"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# script is rerun before running 'make' and 'make install'. If&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-11"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# CONFIGURE=false, only 'make' and 'make install' or run.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-12"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-13"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Kyle M. Douglass, 2018&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-14"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-15"&gt;&lt;/a&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-16"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Move into the source directory.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-17"&gt;&lt;/a&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; micro-manager
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-18"&gt;&lt;/a&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-19"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Undo any previous patches.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-20"&gt;&lt;/a&gt;git checkout -- DeviceAdapters/WieneckeSinske/CAN29.cpp
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-21"&gt;&lt;/a&gt;git checkout -- DeviceAdapters/WieneckeSinske/WieneckeSinske.cpp
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-22"&gt;&lt;/a&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-23"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Patch the broken WieneckeSinske device adapter.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-24"&gt;&lt;/a&gt;patch DeviceAdapters/WieneckeSinske/CAN29.cpp &amp;lt; ../patches/CAN29.cpp.diff &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-25"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; patch DeviceAdapters/WieneckeSinske/WieneckeSinske.cpp &amp;lt; ../patches/WieneckeSinske.cpp.diff
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-26"&gt;&lt;/a&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-27"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Compile MM2.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-28"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-29"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# Remake the entire build system, then compile from scratch.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-30"&gt;&lt;/a&gt;    ./autogen.sh
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-31"&gt;&lt;/a&gt;    &lt;span class="nv"&gt;PYTHON&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/bin/python3"&lt;/span&gt; ./configure &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-32"&gt;&lt;/a&gt;        --prefix&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/micro-manager/src/build"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-33"&gt;&lt;/a&gt;        --with-python&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/include/python3.5"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-34"&gt;&lt;/a&gt;        --with-boost-libdir&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/lib/arm-linux-gnueabihf"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-35"&gt;&lt;/a&gt;        --with-boost&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/include/boost"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-36"&gt;&lt;/a&gt;        --disable-java-app &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-37"&gt;&lt;/a&gt;        --disable-install-dependency-jars &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-38"&gt;&lt;/a&gt;        --with-java&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"no"&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-39"&gt;&lt;/a&gt;    make
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-40"&gt;&lt;/a&gt;    make install
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-41"&gt;&lt;/a&gt;    chmod -R a+w /micro-manager/src/build
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-42"&gt;&lt;/a&gt;&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-43"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# Only recompile changed source files.&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-44"&gt;&lt;/a&gt;    make
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-45"&gt;&lt;/a&gt;    make install
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-46"&gt;&lt;/a&gt;    chmod -R a+w /micro-manager/src/build
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-47"&gt;&lt;/a&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-48"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; : Unrecognized argument."&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-49"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Pass \"true\" to run the full build process."&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-50"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Pass \"false\" to run only \"make\" and \"make install\"."&lt;/span&gt;
&lt;a name="rest_code_c4bdae05ce3949a29a977ba64ad474a1-51"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Most important in this script is the call to &lt;tt class="docutils literal"&gt;configure&lt;/tt&gt;. You can
see that the compiled libraries and Python wrapper will be written to
the build folder inside the mounted directory. This gives the host
file system access to the compiled artifacts after the container has
stopped.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-3-build-the-application-image"&gt;
&lt;h3&gt;Step 3: Build the application image&lt;/h3&gt;
&lt;p&gt;Once the libraries are compiled, we can add them to an application
image that contains only the essentials for running Micro-Manager.&lt;/p&gt;
&lt;p&gt;For this, I use a separate Dockerfile inside the 2.0-python
directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Builds the Micro-Manager 2.0 Python wrapper for the Raspberry Pi.&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: docker build \&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          -t NAME:TAG \&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          .&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-10"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-11"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-13"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-start"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Install the run-time dependencies.&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-16"&gt;&lt;/a&gt;RUN apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get -y install --no-install-recommends &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-17"&gt;&lt;/a&gt;    libatlas-base-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-18"&gt;&lt;/a&gt;    libboost-all-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-19"&gt;&lt;/a&gt;    python3-pip &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-20"&gt;&lt;/a&gt;    python3-setuptools &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-21"&gt;&lt;/a&gt;    python3-wheel &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-22"&gt;&lt;/a&gt;    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; pip3 install numpy &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-23"&gt;&lt;/a&gt;    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-24"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-25"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copy in the Micro-Manager source files.&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-26"&gt;&lt;/a&gt;RUN useradd -ms /bin/bash micro-manager
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-27"&gt;&lt;/a&gt;WORKDIR /home/micro-manager/app
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-28"&gt;&lt;/a&gt;COPY --chown&lt;span class="o"&gt;=&lt;/span&gt;micro-manager:micro-manager . .
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-29"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-30"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-end"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-31"&gt;&lt;/a&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-32"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Final environment configuration.&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-33"&gt;&lt;/a&gt;USER micro-manager:micro-manager
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-34"&gt;&lt;/a&gt;ENV PYTHONPATH /home/micro-manager/app/lib/micro-manager
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-35"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_d2c39a585a2c4f18b05c576e91c7b9e5-36"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/usr/bin/python3"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;As before, I use a clean resin base image. However, this time I only
install the essential software to run Micro-Manager.&lt;/p&gt;
&lt;p&gt;After apt-getting and pip-installing everything, I create a new user
called &lt;strong&gt;micro-manager&lt;/strong&gt; and a new folder called &lt;strong&gt;app&lt;/strong&gt; inside this
user's home directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_429cf0806a154ad1830bf3a72e544697-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copy in the Micro-Manager source files.&lt;/span&gt;
&lt;a name="rest_code_429cf0806a154ad1830bf3a72e544697-2"&gt;&lt;/a&gt;RUN useradd -ms /bin/bash micro-manager
&lt;a name="rest_code_429cf0806a154ad1830bf3a72e544697-3"&gt;&lt;/a&gt;WORKDIR /home/micro-manager/app
&lt;/pre&gt;&lt;p&gt;Next, I directly copy the compiled libraries into the image with the
COPY command.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_669f943f2dbd45fea1871087ea64446f-1"&gt;&lt;/a&gt;COPY --chown&lt;span class="o"&gt;=&lt;/span&gt;micro-manager:micro-manager . .
&lt;/pre&gt;&lt;p&gt;The two periods (.) mean that I copy the current host directory's
contents into the container's current working directory
(/home/micro-manager/app). What is the current host directory? Well,
as I explain below, I actually run this Dockerfile from inside the
&lt;strong&gt;build&lt;/strong&gt; folder that was created to hold the compiled libraries in
the previous step. But first, I'll end my explanation of the
Dockerfile by saying that I switch the USER so that I do not run the
container as root, add the library to the PYTHONPATH environment
variable, and setup the default command as the python3 interpreter.&lt;/p&gt;
&lt;p&gt;To build this image, I use the following build script.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./build DIR&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# DIR is the root directory containing the Micro-Manager build&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# artifacts. These artifacts will be added to the Docker image.&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-10"&gt;&lt;/a&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-12"&gt;&lt;/a&gt;cp Dockerfile &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-13"&gt;&lt;/a&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-15"&gt;&lt;/a&gt;docker build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-16"&gt;&lt;/a&gt;       -t localhost:5000/rpi-micromanager:2.0-python &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_dc3a0e2e3f174899a0f46febdbac5215-17"&gt;&lt;/a&gt;       .
&lt;/pre&gt;&lt;p&gt;This script takes one argument, which is the &lt;strong&gt;build&lt;/strong&gt; directory
containing the compiled source code. The script first copies the
Dockerfile into this directory and then changes into it with the cd
command. (This explains the two periods (.) in the COPY command in the
Dockerfile.)&lt;/p&gt;
&lt;p&gt;Finally, I build the image and give it a name of
localhost:5000/rpi-micromanager:2.0-python.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-4-add-the-image-to-the-local-registry-server"&gt;
&lt;h3&gt;Step 4: Add the image to the local registry server&lt;/h3&gt;
&lt;p&gt;Now we need a way to get the image from the workstation onto the
Raspberry Pi. Of course, I could manually transfer the file with a USB
stick or possibly use ssh, but what if I have multiple Pi's? This
process could become cumbersome. Docker provides a few ways to push
and pull images across a network. The most obvious is &lt;a class="reference external" href="https://hub.docker.com/"&gt;Dockerhub&lt;/a&gt;, a site for freely sharing images. For the
moment I don't want to use Dockerhub, though, because I have not yet
checked all the software licenses and am unsure as to what my rights
are for putting an image with Micro-Manager software on a public
repository.&lt;/p&gt;
&lt;p&gt;A better option, especially for testing, is to use a local registry
server. This server operates only on my home network and already
allows my workstation and Pi's to communicate with one
another. Following the &lt;a class="reference external" href="https://docs.docker.com/registry/deploying/"&gt;official registry documentation&lt;/a&gt; and &lt;a class="reference external" href="http://zacharykeeton.com/docker-private-registry/"&gt;this blog post by
Zachary Keeton&lt;/a&gt;,
I managed to setup the registry as follows.&lt;/p&gt;
&lt;div class="section" id="host-setup"&gt;
&lt;h4&gt;Host setup&lt;/h4&gt;
&lt;p&gt;First, we need to setup a transport layer security (TLS)
certificate. It's possible to run the server without one if you don't
expect your network to be attacked, but it's good practice so let's
create one.&lt;/p&gt;
&lt;p&gt;To do this, I edit the /etc/ssl/openssl.cnf file and add the following
to the top of the [ v3_ca ] section.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
subjectAltName = IP:192.168.XXX.XXX
&lt;/pre&gt;
&lt;p&gt;where the IP address is the address of the workstation on the
network. Next, I actually create the certificate. I make a directory
called certs inside my workstation home directory and then use openssl
to make the cerficate. During the prompts, I press ENTER at every step
except the FQDN (fully qualified domain name). For the FQDN, I enter
the same IP address as above.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_86887feb6b394f85a6cb2b2087c05d36-1"&gt;&lt;/a&gt;mkdir certs
&lt;a name="rest_code_86887feb6b394f85a6cb2b2087c05d36-2"&gt;&lt;/a&gt;openssl req -newkey rsa:4096 -nodes -sha256 &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_86887feb6b394f85a6cb2b2087c05d36-3"&gt;&lt;/a&gt;-keyout certs/domain.key -x509 -days &lt;span class="m"&gt;365&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_86887feb6b394f85a6cb2b2087c05d36-4"&gt;&lt;/a&gt;-config /etc/ssl/openssl.cnf -out certs/domain.crt
&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;I had to add the ``-config /etc/ssl/openssl.cnf`` argument for the
subject alternative name to be added to the certificate.&lt;/strong&gt; This part
was tricky, because if this argument is not included, then the key
generation step will use some other .cnf file (I am not sure
which). This results in the following SAN error when attemptingt to
connect to the registry.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cannot validate certificate for 192.168.XXX.XXX because it doesn't contain any IP SANs
&lt;/pre&gt;
&lt;p&gt;After the domain.key and domain.crt files have been created, I run the
official registry server container. (See how handy Docker containers
are? There's no messy installation beyond grabbing the container.)&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-1"&gt;&lt;/a&gt;docker run -d -p &lt;span class="m"&gt;5000&lt;/span&gt;:5000 &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-2"&gt;&lt;/a&gt;  --restart&lt;span class="o"&gt;=&lt;/span&gt;always &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-3"&gt;&lt;/a&gt;  --name registry &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-4"&gt;&lt;/a&gt;  -v &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;/certs:/certs &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-5"&gt;&lt;/a&gt;  -e &lt;span class="nv"&gt;REGISTRY_HTTP_TLS_CERTIFICATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/certs/domain.crt &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-6"&gt;&lt;/a&gt;  -e &lt;span class="nv"&gt;REGISTRY_HTTP_TLS_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/certs/domain.key &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_0a9896e55c0d4f90aeeca6488c13fa6a-7"&gt;&lt;/a&gt;  registry:2
&lt;/pre&gt;&lt;p&gt;If the registry:2 image is not already downloaded, then it will be
downloaded for automatically when running the container. Note that
the -p 5000:5000 argument indicates that the server is using port 5000
on both the host system and inside the container. Note also that the
certs directory is relative to the current directory because I use the
($pwd) command. You can change this to an absolute path if you wish on
your setup.&lt;/p&gt;
&lt;p&gt;Let's go ahead and push the application image to the server now that
it's running.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_9f2efb97cc1f4405b31df75762cf0ccd-1"&gt;&lt;/a&gt;docker push localhost:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="setup-the-pi"&gt;
&lt;h4&gt;Setup the Pi&lt;/h4&gt;
&lt;p&gt;Now, startup the Pi. I will assume that you have &lt;a class="reference external" href="https://www.raspberrypi.org/blog/docker-comes-to-raspberry-pi/"&gt;already installed
Docker&lt;/a&gt; on
it and know how to communicate with it via ssh and copy files to it
using scp.&lt;/p&gt;
&lt;p&gt;I copy the certificate from the host with scp.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_01f2057272c64a55a7dc30a09662f278-1"&gt;&lt;/a&gt;sudo mkdir -p /etc/docker/certs.d/192.168.XXX.XXX:5000/
&lt;a name="rest_code_01f2057272c64a55a7dc30a09662f278-2"&gt;&lt;/a&gt;sudo scp kmdouglass@192.168.XXX.XXX:/home/kmdouglass/certs/domain.crt /etc/docker/certs.d/192.168.XXX.XXX:5000/ca.crt
&lt;/pre&gt;&lt;p&gt;The IP address that I am using is the one to the machine where the
registry server is running. After this step, I make the operating
system trust the certificate.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_b992be5945ec448c99eb26412ad3fcd8-1"&gt;&lt;/a&gt;sudo scp kmdouglass@192.168.XXX.XXX:/home/kmdouglass/certs/domain.crt /usr/local/share/ca-certificates/192.168.XXX.XXX.crt
&lt;a name="rest_code_b992be5945ec448c99eb26412ad3fcd8-2"&gt;&lt;/a&gt;sudo update-ca-certifications
&lt;/pre&gt;&lt;p&gt;Finally, I restart the Docker daemon.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_2ad10e9d31d944548082cd85d6f25f6d-1"&gt;&lt;/a&gt;sudo service docker restart
&lt;/pre&gt;&lt;p&gt;If everything is working, then I should be able to pull the image from
your network's registry server.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f9dbff5d6425426489523f7e12278aab-1"&gt;&lt;/a&gt;docker pull &lt;span class="m"&gt;192&lt;/span&gt;.168.XXX.XXX:5000/rpi-micromanager:python2.0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-5-run-micro-manager"&gt;
&lt;h3&gt;Step 5: Run Micro-Manager!&lt;/h3&gt;
&lt;p&gt;And now the moment of truth: running the application container. Since
it's setup to run Python automatically, I use a pretty simple &lt;tt class="docutils literal"&gt;docker
run&lt;/tt&gt; command.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_44303c2f70dc4c699fe02dd7140e1c76-1"&gt;&lt;/a&gt;docker run -it --rm &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_44303c2f70dc4c699fe02dd7140e1c76-2"&gt;&lt;/a&gt;     --name micro-manager &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_44303c2f70dc4c699fe02dd7140e1c76-3"&gt;&lt;/a&gt;     &lt;span class="m"&gt;192&lt;/span&gt;.168.XXX.XXX:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;&lt;p&gt;I verify that the Micro-Manager Python wrapper is working by trying to
import it and run &lt;a class="reference external" href="https://micro-manager.org/wiki/Using_the_Micro-Manager_python_library"&gt;a few basic commands&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_5bd277414f21415497aef665e01aa4dc-1"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;MMCorePy&lt;/span&gt;
&lt;a name="rest_code_5bd277414f21415497aef665e01aa4dc-2"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mmc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MMCorePy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CMMCore&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_5bd277414f21415497aef665e01aa4dc-3"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mmc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getVersionInfo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;If these work without error, then congratulations! You're now ready to
start building your embedded microscopy system ;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-6-running-the-whole-process"&gt;
&lt;h3&gt;Step 6: Running the whole process&lt;/h3&gt;
&lt;p&gt;The beauty of having scripted all these steps is that the full
workflow may be executed quite simply. From the host system's build
folder, run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/build$ ./build
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/build$ ./run /path/to/source true
&lt;/pre&gt;
&lt;p&gt;From the 2.0-python folder:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/2.0-python ./build /path/to/source/artifacts
kmdouglass@xxxxx:~$ docker push localhost:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;
&lt;p&gt;And from the Raspberry Pi:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pi@yyyyy:~$ docker pull 192.168.XXX.XXX:5000/rpi-micromanager:2.0-python
pi@yyyyy:~$ docker run -it --rm \
                   --name micro-manager \
                   192.168.XXX.XXX:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;
&lt;p&gt;Hopefully this is enough to get you started building Micro-Manager for
the Raspberry Pi with Docker. Though I focused on Micro-Manager, the
workflow should be generally applicable to any large scale project in
which you want to isolate the build environment from the host machine.&lt;/p&gt;
&lt;p&gt;If you have any questions, just leave them in the comments. Happy
programming!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>docker</category><category>micro-manager</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/how-i-built-a-cross-compilation-workflow-for-the-raspberry-pi/</guid><pubDate>Sun, 29 Apr 2018 10:10:26 GMT</pubDate></item><item><title>Micro-Manager on the Raspberry Pi</title><link>http://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="https://micro-manager.org/"&gt;Micro-Manager&lt;/a&gt; is an open source platform for controlling microscope
hardware, automating image acquisition, and tracking metadata about
how images are acquired. In biomedical imaging research, it serves as
an incredibly important tool because it is free and open source, which
means that scientists can benefit from the contributions of others to
the software without paying costly licensing fees.&lt;/p&gt;
&lt;p&gt;I recently managed to compile Micro-Manager version 2.0 on the
Raspberry Pi. I did this for a small hobby project I am working on to
build a cheap yet effective tool for &lt;a class="reference external" href="https://hackaday.io/project/19677-basic-lensless-imaging-for-low-cost-microscopy"&gt;at-home microscope projects and
hacking&lt;/a&gt;. Though I am not yet convinced that Micro-Manager will be
the best tool for this particular job given it's relatively heavy
footprint on the Pi's slower hardware, I thought that I would post my
notes so that others could benefit from my experience.&lt;/p&gt;
&lt;div class="section" id="software-versions"&gt;
&lt;h2&gt;Software versions&lt;/h2&gt;
&lt;p&gt;I am working with a Raspberry Pi 3 Model B:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pi@raspberrypi:~ $ uname -a &amp;amp; gcc -dumpversion &amp;amp; make -v &amp;amp; ldd --version
Linux raspberrypi 4.4.38-v7+ #938 SMP Thu Dec 15 15:22:21 GMT 2016 armv7l GNU/Linux

pi@raspberrypi:~ $ gcc -dumpversion
4.9.2

pi@raspberrypi:~ $ make -v
GNU Make 4.0

pi@raspberrypi:~ $ ldd --version
ldd (Debian GLIBC 2.19-18+deb8u7) 2.19
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-a-network-share-for-3rd-party-libraries"&gt;
&lt;h2&gt;Setup a network share for 3rd party libraries&lt;/h2&gt;
&lt;p&gt;We need to compile Micro-Manager because binares for the Pi's ARM
processor are not distributed by the Micro-Manager team (probably
because too few people have ever wanted them). To compile
Micro-Manager, we need to checkout a rather large set of 3rd party
libraries. When I last checked, these libraries occupied 6.7 GB of
space on my laptop, a size which can be prohibitive when using the
Micro-SD cards that provide storage for the Pi.&lt;/p&gt;
&lt;p&gt;To circumvent this problem, I checked out the &lt;strong&gt;3rdpartypublic&lt;/strong&gt; SVN
repository onto my laptop and created a network share from this
directory. Then, I mounted the share on my Pi in the directory just
above that containing the Micro-Manager source code.&lt;/p&gt;
&lt;p&gt;To get started, first have a look at my post on connecting a Pi to a
Linux home network for ideas if you haven't already connected the Pi
to your other machines at home:
&lt;a class="reference external" href="http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html"&gt;http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once the Pi and the laptop are on the same network, checkout the SVN
3rdpartypublic repository onto your laptop or home server. You may
need to do this a few times until completion because the downloads can
timeout after a few minutes:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svn checkout https://valelab4.ucsf.edu/svn/3rdpartypublic/
&lt;/pre&gt;
&lt;p&gt;Next, we need to setup the network share. If your laptop or server is
running Windows, then you will probably need to setup &lt;a class="reference external" href="https://www.samba.org/samba/what_is_samba.html"&gt;Samba&lt;/a&gt; on the
Pi to share files between them. I however am running a Linux home
network, so I decided to use &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Network_File_System"&gt;NFS&lt;/a&gt; (Network File Sharing) to share
the directory between my laptop--which runs Debian Linux--and the
Pi. I installed NFS on my laptop with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install nfs-kernel-server nfs-common
&lt;/pre&gt;
&lt;p&gt;Once installed, I added the following line to the newly created
/etc/exports file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/home/kmdouglass/src/micro-manager/3rdpartypublic 192.168.0.2/24(ro)
&lt;/pre&gt;
&lt;p&gt;The first part is the directory to share, i.e. where the
3rdpartypublic directory is stored on my laptop. The second part
contains the static IP address of the Pi on my home network. The /24
was REQUIRED for my client (the Pi) to mount the share. /24 simply
denotes a network mask of 255.255.255.0; if you have a different mask
on your network, then you can find a good discussion on this topic
here: &lt;a class="reference external" href="https://arstechnica.com/civis/viewtopic.php?t=751834"&gt;https://arstechnica.com/civis/viewtopic.php?t=751834&lt;/a&gt; Finally,
(...)  specifies shared options and &lt;strong&gt;ro&lt;/strong&gt; means read only.&lt;/p&gt;
&lt;p&gt;After editing the file, export the folder and restart the NFS server:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo exportfs -arv
sudo /etc/init.d/nfs-kernel-server restart
&lt;/pre&gt;
&lt;p&gt;On the client (the Pi), the NFS client software was already
installed. However, I had to restart the rpcbind service before I
could mount the share:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo /etc/init.d/rpcbind restart
&lt;/pre&gt;
&lt;p&gt;Finally, I added a line to the &lt;strong&gt;/etc/fstab&lt;/strong&gt; file on the Pi to make
mounting the 3rdpartypublic share easier:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
192.168.0.102:/home/kmdouglass/src/micro-manager/3rdpartypublic /home/pi/src/micro-manager/3rdpartypublic nfs user,noauto 0 0
&lt;/pre&gt;
&lt;p&gt;The first part indicates the IP of the laptop and the share to
mount. The second part, &lt;strong&gt;/home/pi/src/micro-manager/3rdpartypublic&lt;/strong&gt;
is the directory on the Pi where the share will be mounted. I placed
this one directory above where the MM source code is,
(&lt;strong&gt;/home/pi/src/micro-manager/micro-manager&lt;/strong&gt; on my machine). &lt;strong&gt;nfs&lt;/strong&gt;
indicates the type of share to mount, and &lt;strong&gt;user,noauto&lt;/strong&gt; permits any
user to mount the share (not just root), though this share will not be
automatically mounted when the Pi starts. The final two zeros are
explained in the fstab comments but aren't really important for us. To
mount the share, type the following on the Pi:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo mount /home/pi/src/micro-manager/3rdpartypublic
&lt;/pre&gt;
&lt;p&gt;In case you're interested in learning more about the intricacies of
Linux home networking, I found the following sources of information to
be incredibly helpful.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.howtoforge.com/install_nfs_server_and_client_on_debian_wheezy"&gt;https://www.howtoforge.com/install_nfs_server_and_client_on_debian_wheezy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=luqq8DUqqCw"&gt;https://www.youtube.com/watch?v=luqq8DUqqCw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://nfs.sourceforge.net/nfs-howto/ar01s03.html#config_server_setup"&gt;http://nfs.sourceforge.net/nfs-howto/ar01s03.html#config_server_setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tecmint.com/how-to-setup-nfs-server-in-linux/"&gt;http://www.tecmint.com/how-to-setup-nfs-server-in-linux/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="building-mm"&gt;
&lt;h2&gt;Building MM&lt;/h2&gt;
&lt;p&gt;Once I was able to mount the share containing 3rd party libraries, I
installed the following packages on the Pi and checked out the
Micro-Manager source code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install autoconf automake libtool pkg-config swig ant libboost-dev libboost-all-dev
cd ~/src/micro-manager
git clone https://github.com/micro-manager/micro-manager.git
cd micro-manager
git checkout mm2
&lt;/pre&gt;
&lt;p&gt;The last command switches to the mm2 branch where the Micro-Manager
2.0 source code is found. Note that it may not be necessary to install
all of the boost libraries with &lt;code&gt;sudo apt-get install
libboost-all-dev&lt;/code&gt;, but I did this anyway because I encountered
multiple errors due to missing boost library files the first few times
I tried compiling.&lt;/p&gt;
&lt;p&gt;The next step follows the normal Micro-Manager build routine using
make, with the exception of the configuration step. From inside the
Micro-Manager source code directory on the Pi, run the following
commands one at a time:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./autogen.sh
PYTHON=/usr/bin/python3 ./configure --prefix=/opt/micro-manager --with-ij-jar=/usr/share/java/ij.jar --with-python=/usr/include/python3.4 --with-boost-libdir=/usr/lib/arm-linux-gnueabihf --with-boost=/usr/include/boost
make fetchdeps
make
sudo make install
&lt;/pre&gt;
&lt;p&gt;In the configuration step, I set the Python interpreter to Python 3
because I greatly prefer it over Python 2. This is done by setting the
&lt;strong&gt;PYTHON&lt;/strong&gt; environment variable before running
configure. &lt;strong&gt;--prefix=/opt/micro-manager/&lt;/strong&gt; indicates the preferred
installation directory of
Micro-Manager. &lt;strong&gt;--with-ij-jar=/usr/share/java/ij.jar&lt;/strong&gt; is the path to
the ImageJ Java library, though I am uncertain whether this was
necessary. (I installed ImageJ with a &lt;code&gt;sudo apt-get install
imagej&lt;/code&gt; a while ago.) &lt;strong&gt;--with-python=/usr/include/python3.4&lt;/strong&gt; should
point to the directory containing the &lt;strong&gt;Python.h&lt;/strong&gt; header file for the
version of Python you are compiling against. &lt;strong&gt;with-boost-libdir&lt;/strong&gt;
should point to the directory containing the boost libraries (.so
files). This was critical for getting MM2 to build. If you are unsure
where they are located, you can search for them with &lt;code&gt;sudo find
/ -name "libboost*"&lt;/code&gt;. Finally, the last option, &lt;strong&gt;with-boost&lt;/strong&gt;, may or
may not be necessary. I set it to the directory containing the boost
headers but never checked to see whether MM compiles without it.&lt;/p&gt;
&lt;p&gt;If all goes well, Micro-Manager will compile and install without
problems. Compilation time on my Pi took around one hour.&lt;/p&gt;
&lt;div class="section" id="set-the-maximum-amount-of-direct-memory"&gt;
&lt;h3&gt;Set the maximum amount of direct memory&lt;/h3&gt;
&lt;p&gt;In the next step, we need to make a minor edit to the Micro-Manager
Linux start script. Edit the script
(/opt/micro-manager/bin/micromanager) to reduce the maximum direct
memory to something reasonable:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt/bin/java -Xmx1024M \
  -XX:MaxDirectMemorySize=1000G \
   -classpath "$CLASSPATH" \
   -Dmmcorej.library.loading.stderr.log=yes \
   -Dmmcorej.library.path="/opt/micro-manager/lib/micro-manager" \
   -Dorg.micromanager.plugin.path="/opt/micro-manager/share/micro-manager/mmplugins" \
&lt;/pre&gt;
&lt;p&gt;Change 1000G to 512M or 256M; otherwise the Pi will complain that the
MaxDirectMemorySize of 1000G is too large. You can start Micro-Manager
by running this modified script.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;Though Micro-Manager compiles and runs on the Pi, I have not yet
tested it thoroughly acquisitions. I am currently waiting on a camera
board to arrive in the mail, and when it does, I will attempt to
interface with it through Micro-Manager. Though I could write my own
Python library, Micro-Manager is appealing because it can save a lot
of time by providing a ready-made means to annotate, process, and
store imaging data.&lt;/p&gt;
&lt;p&gt;Running Micro-Manager on the Pi also raises the possibility of a fully
open, embedded biomedical imaging platform, though I am uncertain at
the moment whether the hardware on the Pi is up to the task. If you
manage to do anything cool with Micro-Manager and the Raspberry Pi,
please let me know in the comments!&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>micro-manager</category><category>microscopy</category><category>open source</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi/</guid><pubDate>Fri, 10 Feb 2017 18:31:57 GMT</pubDate></item><item><title>Reading select lines from a text file</title><link>http://kmdouglass.github.io/posts/reading-select-lines-from-a-text-file/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="https://gist.github.com/kmdouglass/507717d339bc82f850ce"&gt;I just created a Python Gist&lt;/a&gt; for
reading select lines from a text file into memory. I came up with this Gist when I needed to parse
the core log from our &lt;a class="reference external" href="https://www.micro-manager.org/"&gt;microscope control software (Micro-Manager)&lt;/a&gt;. One of our devices was continously sending its statistics to
the computer, which would then be recorded to the log. I wanted to find only lines that contained
the statistics by searching for the &lt;em&gt;STATS&lt;/em&gt; identifier, which was unique to these lines.&lt;/p&gt;
&lt;p&gt;The problem was a bit more difficult than reading just the lines containing this string because I
wanted the statistics only for times when the software was acquiring a time series of
images. Luckily, the core log also contains lines with unique strings indicating when a time series
was initiated and stopped. All lines in the log are time-stamped.&lt;/p&gt;
&lt;p&gt;Below is the Gist I used to solve this problem. The lines that will be retained in memory will
contain the strings in the list lineFilters. I then define a function named stringIsIn that will
return a list of bool indicating whether each string is present in the line.&lt;/p&gt;
&lt;p&gt;At the bottom of the Gist, I use a list comprehension to loop over each line in the file. The line
is appended to a growing list called outputLines if the line contains &lt;em&gt;any&lt;/em&gt; of the strings I
defined. Note that it's not necessary to use a separate definition for &lt;cite&gt;stringIsIn&lt;/cite&gt;; the list
comprehension over lineFilters could have been placed inline with the primary list comprension over
lines in the file. I do think it is more readable the way it is presented below, however.&lt;/p&gt;
&lt;p&gt;I welcome any comments or suggestions, especially on the &lt;a class="reference external" href="https://gist.github.com/kmdouglass/507717d339bc82f850ce"&gt;Gist website&lt;/a&gt; where others may be more likely to find
it.&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-1"&gt;&lt;/a&gt;&lt;span class="n"&gt;filename&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'myFile.txt'&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;outputLines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-3"&gt;&lt;/a&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Keep all lines containing ANY of the following list of strings.&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;lineFilters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'line 1'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-6"&gt;&lt;/a&gt;               &lt;span class="s1"&gt;'line 2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-7"&gt;&lt;/a&gt;               &lt;span class="s1"&gt;'line 3'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-8"&gt;&lt;/a&gt;&lt;span class="n"&gt;stringIsIn&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;filter&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lineFilters&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-10"&gt;&lt;/a&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-11"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Read only lines containing one of the strings into memory.&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-12"&gt;&lt;/a&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'r'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a name="rest_code_893212ffccc44238897c8ac2b9ad1988-13"&gt;&lt;/a&gt;    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;outputLines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;any&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stringIsIn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>micro-manager</category><category>python</category><guid>http://kmdouglass.github.io/posts/reading-select-lines-from-a-text-file/</guid><pubDate>Wed, 18 Mar 2015 07:27:50 GMT</pubDate></item></channel></rss>