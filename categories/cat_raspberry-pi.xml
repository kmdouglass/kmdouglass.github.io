<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (Posts about raspberry pi)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link href="http://kmdouglass.github.io/categories/cat_raspberry-pi.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 26 Feb 2019 05:58:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Create a custom Raspbian image with pi-gen: part 2</title><link>http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-2/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;In my &lt;a class="reference external" href="http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-1/"&gt;previous post&lt;/a&gt;, I discussed how to setup user accounts and
locales in a custom Raspbian image using pi-gen. In this follow-up
post, I will discuss the main problems that I want to solve:
automatically configuring the wireless network and ssh on a new
Raspberry Pi without a terminal attached directly to the Pi.&lt;/p&gt;
&lt;div class="section" id="set-up-the-wireless-network"&gt;
&lt;h2&gt;Set up the wireless network&lt;/h2&gt;
&lt;div class="section" id="the-wpa-supplicant"&gt;
&lt;h3&gt;The WPA supplicant&lt;/h3&gt;
&lt;p&gt;The Pi's wireless credentials are configured in stage 2 in the file
&lt;strong&gt;stage2/02-net-tweaks/files/wpa_supplicant.conf&lt;/strong&gt;. Here's how it
looks by default:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
&lt;/pre&gt;
&lt;p&gt;According to the blogs &lt;a class="reference external" href="https://learnthinksolvecreate.wordpress.com/2017/07/25/pi-gen-setting-default-wifi-settings/"&gt;Learn Think Solve Create&lt;/a&gt; and the &lt;a class="reference external" href="https://www.raspberrypi-spy.co.uk/2017/04/manually-setting-up-pi-wifi-using-wpa_supplicant-conf/"&gt;Raspberry
Spy&lt;/a&gt;, the first thing we should do is add our country code to the top
of this file with the line &lt;cite&gt;country=CH&lt;/cite&gt;. (Use your own country code
for this.) Next, we want to enter the details for our wireless
network, which includes its name and the password. For security
reasons that I hope are obvious, we should not store the password in
this file. Instead, we create a hash of the password and put that
inside the file. The command to create the password hash is&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c27f64fba4694375849fbb6aaa45bb14-1"&gt;&lt;/a&gt;wpa_passphrase ESSID PASSWORD &amp;gt; psk
&lt;/pre&gt;&lt;p&gt;where ESSID is our wireless network's name. Note that I also used a
space before the &lt;code class="shell"&gt;wpa_passphrase&lt;/code&gt; command to prevent the
password being written to my .bash_history file. Now, we copy and
paste the contents of the file &lt;strong&gt;psk&lt;/strong&gt; into the wpa_supplicant.conf
and remove the comment that contains the actual password:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
country=CH
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid=YOUR_ESSID_HERE
        psk=YOUR_PSK_HASH_HERE
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-wireless-network-interfaces"&gt;
&lt;h3&gt;Configure the wireless network interfaces&lt;/h3&gt;
&lt;p&gt;After having configured the supplicant, we next move on to configuring
the network interfaces used by Raspbian. The appropriate file is found
in &lt;strong&gt;stage1/02-net-tweaks/files/interfaces&lt;/strong&gt;. In my post &lt;a class="reference external" href="http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network/"&gt;Connecting a
Raspberry Pi to a Home Linux Network&lt;/a&gt; I described how to set up the
network interfaces by editing &lt;strong&gt;/etc/network/interfaces&lt;/strong&gt;. Much of the
information presented in that post has now been superseded in Raspbian
by the DHCP daemon. For now, we will use the interfaces file to
instruct our Pi to use DHCP and will use &lt;strong&gt;/etc/dhcpcd.conf&lt;/strong&gt; at a
later time to set up a static IP address when provisioning the Pi.&lt;/p&gt;
&lt;p&gt;We first need to make a few changes to make the interfaces file aware
of the credentials in the wpa supplicant configuration file. According
to the blog &lt;a class="reference external" href="https://kerneldriver.wordpress.com/2012/10/21/configuring-wpa2-using-wpa_supplicant-on-the-raspberry-pi/"&gt;kerneldriver&lt;/a&gt;, we need modify the
/etc/networe/interfaces file as such:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
auto lo

iface lo inet loopback
iface eth0 inet dhcp

auto wlan0
iface wlan0 inet manual
     wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/pre&gt;
&lt;p&gt;In the first modification, I specify that I want the wirless interface
&lt;strong&gt;wlan0&lt;/strong&gt; started automatically with &lt;cite&gt;auto wlan0&lt;/cite&gt;. Next, I specify
that the wlan0 interface should use the &lt;a class="reference external" href="https://manpages.debian.org/stretch/ifupdown/interfaces.5.en.html#The_manual_Method"&gt;manual inet address family&lt;/a&gt;
with the line &lt;cite&gt;iface wlan0 inet manual&lt;/cite&gt;.&lt;/p&gt;
&lt;p&gt;According to the man pages, "[the manual] method may be used to define
interfaces for which no configuration is done by default." After this
we use the &lt;cite&gt;wpa-roam&lt;/cite&gt; command to specify the location of the
wpa_supplicant.conf file that we previously modified. The wireless
ESSID and password are therefore not defined in interfaces, but rather
reference them inside wpa_supplicant.conf.&lt;/p&gt;
&lt;p&gt;In case you noticed that wpa-roam doesn't appear as an option in
documentation on the interfaces file and were wondering why, it's
because other programs like wpasupplicant may provide additional
options to the interfaces file. A similar command is &lt;cite&gt;wpa-conf&lt;/cite&gt;, but I
do not quite yet understand the difference between these two commands.&lt;/p&gt;
&lt;p&gt;Following the wpa-roam command, we configure the default options for
all networks in our wpa_supplicant.conf file with the line &lt;cite&gt;iface
default inet dhcp&lt;/cite&gt;. At this point, we save the setup of the static IP
address for a later time.&lt;/p&gt;
&lt;p&gt;For more information, see &lt;a class="reference external" href="https://manpages.debian.org/stretch/ifupdown/interfaces.5.en.html"&gt;the interfaces man page for Debian
Stretch&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="change-the-hostname"&gt;
&lt;h3&gt;Change the hostname&lt;/h3&gt;
&lt;p&gt;Our Pi's hostname may be changed from the default (raspberrypi) by
modifying the line in &lt;strong&gt;stage1/02-net-tweaks/files/hostname&lt;/strong&gt;. See
&lt;a class="reference external" href="https://tools.ietf.org/html/rfc1178"&gt;RFC 1178&lt;/a&gt; for tips on choosing a hostname.&lt;/p&gt;
&lt;p&gt;In addition to modifying the hostname file, we need to update
&lt;strong&gt;stage1/02-net-tweaks/00-patches/01-hosts.diff&lt;/strong&gt; and change
raspberrypi to the new hostname:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Index: jessie-stage1/rootfs/etc/hosts
===================================================================
--- jessie-stage1.orig/rootfs/etc/hosts
+++ jessie-stage1/rootfs/etc/hosts
@@ -3,3 +3,4 @@
 ff02::1                ip6-allnodes
 ff02::2                ip6-allrouters

+127.0.1.1      NEW_HOSTNAME_HERE
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="set-the-dns-servers"&gt;
&lt;h3&gt;Set the DNS servers&lt;/h3&gt;
&lt;p&gt;DNS servers are configured in
&lt;strong&gt;export-image/02-network/files/resolv.conf&lt;/strong&gt;. By default, mine was
already configured to use one of Google's DNS servers (8.8.8.8). I
added a secondary Google DNS address as well:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
nameserver 8.8.8.8
nameserver 8.8.4.4
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="enable-ssh"&gt;
&lt;h2&gt;Enable SSH&lt;/h2&gt;
&lt;p&gt;Enabling SSH is simple. Open &lt;strong&gt;stage2/01-sys-tweaks/01-run.sh&lt;/strong&gt; and
change the line &lt;code class="shell"&gt;systemctl disable ssh&lt;/code&gt; to &lt;code class="shell"&gt;systemctl
&lt;span class="nb"&gt;enable&lt;/span&gt; ssh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(I later learned that we can also enable ssh on a headless pi by
adding an empty file named &lt;strong&gt;ssh&lt;/strong&gt; to the boot partition of a standard
Raspbian image. See here for more details:
&lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/ssh/"&gt;https://www.raspberrypi.org/documentation/remote-access/ssh/&lt;/a&gt;)&lt;/p&gt;
&lt;div class="section" id="configuring-ssh-keys-or-not"&gt;
&lt;h3&gt;Configuring SSH keys (or not)&lt;/h3&gt;
&lt;p&gt;I decided after writing much of this tutorial that pi-gen was not
necessarily the best tool for adding my public SSH keys. So long as I
have network access and SSH enabled, I can easily add my keys using
&lt;code class="shell"&gt;ssh-copy-id&lt;/code&gt;. Furthermore, after following this tutorial,
there still remains a lot of setup and customization steps. These can
more easily be performed manually or by server automation tools like
&lt;a class="reference external" href="http://www.fabfile.org/"&gt;Fabric&lt;/a&gt; or &lt;a class="reference external" href="https://www.ansible.com/"&gt;Ansible&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Therefore, I think that at this point we can stop with our
customization of the image with pi-gen and move to a different
tool. We have a basic Raspbian image that is already configured for
our home network and that serves as a starting point for more complete
customization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This tutorial and my &lt;a class="reference external" href="http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-1/"&gt;previous post&lt;/a&gt; demonstrated how to create a
custom Raspbian image that is pre-configured for&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;our home wireless network&lt;/li&gt;
&lt;li&gt;our locale information&lt;/li&gt;
&lt;li&gt;ssh&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, we can do much, much more with pi-gen, but other tools
exist for the purpose of configuring a server. These tutorials at
least allow you to setup a new Raspberry Pi without having to manually
configure its most basic functionality. Happy Pi'ing!&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>devops</category><category>raspberry pi</category><category>raspbian</category><guid>http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-2/</guid><pubDate>Tue, 24 Jul 2018 16:25:26 GMT</pubDate></item><item><title>Create a custom Raspbian image with pi-gen: part 1</title><link>http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-1/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;Docker has been an amazing tool for improving my development
efficiency on the Raspberry Pi. For example, I recently used it to
&lt;a class="reference external" href="http://kmdouglass.github.io/posts/how-i-built-a-cross-compilation-workflow-for-the-raspberry-pi/"&gt;cross-compile a large C++ and Python library&lt;/a&gt; for the Pi's ARM
architecture on my x86_64 laptop. However, in that post I took it for
granted that I had already set up my Raspberry Pi with user accounts,
packages, ssh keys, etc. Performing these steps manually on a fresh
install of the Pi's &lt;a class="reference external" href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian&lt;/a&gt; operating system can become tedious,
especially because ssh needs to be manually enabled before doing any
remote work.&lt;/p&gt;
&lt;p&gt;Fortunately, the Raspberry Pi developers have provided us with
&lt;a class="reference external" href="https://github.com/RPi-Distro/pi-gen"&gt;pi-gen&lt;/a&gt;, a useful collection of Shell scripts and a Docker container
for creating custom Raspbian images. In this post, I will summarize
the steps that I take in using pi-gen to create my own, personalized
Raspbian image.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After I wrote this post, I found a set of posts at&lt;/em&gt; &lt;a class="reference external" href="https://learnthinksolvecreate.wordpress.com/category/raspberry-pi/pi-gen/"&gt;Learn Think
Solve Create&lt;/a&gt; &lt;em&gt;that describe many of the tasks I explain here. Be
sure to check them out for another take on modifying Raspbian images.&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="clone-the-pi-gen-repository"&gt;
&lt;h2&gt;Clone the pi-gen repository&lt;/h2&gt;
&lt;p&gt;This is as easy as cloning the git repository.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f60c98ac9ed740229a8d1cd88fc56b44-1"&gt;&lt;/a&gt;git clone git@github.com:RPi-Distro/pi-gen.git
&lt;/pre&gt;&lt;p&gt;Alternatively, you can use the https address instead of ssh, which is
&lt;a class="reference external" href="https://github.com/RPi-Distro/pi-gen.git"&gt;https://github.com/RPi-Distro/pi-gen.git&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From now on, all directories in this post will be relative to the root
pi-gen directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="build-the-official-raspbian-images"&gt;
&lt;h2&gt;Build the official Raspbian images&lt;/h2&gt;
&lt;p&gt;By default, the pi-gen repository will build the official Raspbian
images. Doing this once before making any modifications is probably a
good idea; if you can't build the official images, how will you be
able to build a custom image?&lt;/p&gt;
&lt;p&gt;There are two main scripts that you can use to do this: &lt;strong&gt;build.sh&lt;/strong&gt;
and &lt;strong&gt;build-docker.sh&lt;/strong&gt;. build.sh requires you to install the packages
that are listed in the repository's README.md file, whereas
build-docker.sh requires only that you have Docker already installed
on your computer. I'm going to be using the Docker-based build script
for the rest of this post. If you don't have Docker installed on your
system, you can &lt;a class="reference external" href="https://docs.docker.com/install/"&gt;follow the instructions here&lt;/a&gt; for the community
edition.&lt;/p&gt;
&lt;div class="section" id="name-your-image"&gt;
&lt;h3&gt;Name your image&lt;/h3&gt;
&lt;p&gt;First we need to give a name to our image, even if we use the default
build. To do this, we assign a name to a variable called &lt;strong&gt;IMG_NAME&lt;/strong&gt;
inside a file called &lt;strong&gt;config&lt;/strong&gt; that is located inside the root pi-gen
folder.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_45a053e14a07456bbabaf0969a9753ab-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"IMG_NAME=my_name"&lt;/span&gt; &amp;gt; config
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="build-the-default-image"&gt;
&lt;h3&gt;Build the default image&lt;/h3&gt;
&lt;p&gt;Once we've named our image, we can go ahead and run the build script.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_cf0c2072324e4b81b8942e516fda60e2-1"&gt;&lt;/a&gt;./build-docker.sh
&lt;/pre&gt;&lt;p&gt;Be prepared to wait a while when running this script; the full build
took well over half an hour on my laptop and with the Docker volume
located on a SSD. It also consumed several GB of space on the SSD.&lt;/p&gt;
&lt;div class="section" id="resuming-a-failed-build"&gt;
&lt;h4&gt;Resuming a failed build&lt;/h4&gt;
&lt;p&gt;The first time I used pi-gen the build failed twice. Once, it hung
without doing anything for several minutes, so I canceled it with a
&lt;strong&gt;Ctrl-C&lt;/strong&gt; command. The other time I encountered a hash error when
installing a Debian package.&lt;/p&gt;
&lt;p&gt;We can resume a failed build from the point of failure by assigning
the value 1 to the CONTINUE variable when calling build-docker.sh
again.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_26c9a5f6c2f246a6abf52cdd223358e4-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;CONTINUE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; ./build-docker.sh
&lt;/pre&gt;&lt;p&gt;If we don't want to run previously built stages, we can simply place a
file inside the corresponding folder named SKIP. For example, if our
build fails at stage2, we can place SKIP files inside the stage0 and
stage1 folders, then rerun the build-docker.sh script with
CONTINUE=1.&lt;/p&gt;
&lt;p&gt;Unfortunately, I have sometimes noticed that I have to also rebuild
the stage &lt;em&gt;prior&lt;/em&gt; to the one where the build failed. In the worst
case, I had to rebuild all the stages because the fixes I applied to a
file in stage2 were not accounted for when I tried to skip building
stages 0 and 1. YMMV with this; I have no idea how well the SKIP
mechanism works for the normal build.sh script.&lt;/p&gt;
&lt;p&gt;After a successful build, we can find our custom images located inside
the &lt;strong&gt;deploy&lt;/strong&gt; folder of the pi-gen directory. These may then be
written onto a SD card and used as a standard Raspbian image.&lt;/p&gt;
&lt;p&gt;We can ensure that the build container is preserved even after successful
builds using&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_de2f9edaba4a4bcaaf8a746fcb7ff95d-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;PRESERVE_CONTAINER&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; ./build-docker.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="custom-raspbian-images"&gt;
&lt;h2&gt;Custom Raspbian images&lt;/h2&gt;
&lt;p&gt;Now that we've got the default build working, let's start by
customizing the build process. For this post, I have the following
goals:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Build only the &lt;em&gt;lite&lt;/em&gt; version of the Raspbian images&lt;/li&gt;
&lt;li&gt;Add a custom user account and delete the default &lt;em&gt;pi&lt;/em&gt; account&lt;/li&gt;
&lt;li&gt;Set the Pi's locale information&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a follow-up post, I will discuss the following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Setup the WiFi for a home network&lt;/li&gt;
&lt;li&gt;Setup ssh so that we can log on to the Pi remotely on its first
startup&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="building-just-raspbian-lite"&gt;
&lt;h3&gt;Building just Raspbian Lite&lt;/h3&gt;
&lt;p&gt;Raspbian Lite is a &lt;a class="reference external" href="https://raspberrypi.stackexchange.com/questions/39932/differences-between-raspbian-jessie-and-raspbian-jessie-lite#39933"&gt;minimal Raspbian image&lt;/a&gt; without the X windows
server and speciality modules that would otherwise make Raspbian more
user friendly. It's an ideal starting point for projects that are
highly specialized, require only a few packages, and do not require a
GUI.&lt;/p&gt;
&lt;p&gt;pi-gen creates Raspbian images in sequential steps called stages. At
the time of this writing, there were five stages, with stages 2, 4,
and 5 producing images of the operating system. Building everything
from stage 0 up to and including stage 2 produces a Raspbian Lite
image. We can speed up the build process and save harddrive space by
disabling all the later stages.&lt;/p&gt;
&lt;p&gt;To disable the build for a particular a stage, we add an empty file
called &lt;strong&gt;SKIP&lt;/strong&gt; inside the corresponding stage folder of the pi-gen
root directory, just as we did above when skipping previously built
stages. We also disable the explicit creation of images by adding an
empty file called &lt;strong&gt;SKIP_IMAGES&lt;/strong&gt; to stages 4 and 5. (We don't need to
add a SKIP_IMAGES file to the stage3 folder because no image is
produced at this stage.)&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_871c874d3f754e0085b9ffbe9cee9284-1"&gt;&lt;/a&gt;touch ./stage3/SKIP ./stage4/SKIP ./stage5/SKIP
&lt;a name="rest_code_871c874d3f754e0085b9ffbe9cee9284-2"&gt;&lt;/a&gt;touch ./stage4/SKIP_IMAGES ./stage5/SKIP_IMAGES
&lt;/pre&gt;&lt;p&gt;Now, when we run build-docker.sh, pi-gen will only build and produce
one image for Raspbian Lite in the deploy directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-a-custom-user-account"&gt;
&lt;h3&gt;Add a custom user account&lt;/h3&gt;
&lt;p&gt;The default user in Raspbian is called &lt;strong&gt;pi&lt;/strong&gt;. This account is created
in stage1 in the the script &lt;strong&gt;stage1/01-sys-tweaks/00-run.sh&lt;/strong&gt;. This
account is not very secure because it and its password, &lt;em&gt;raspberry&lt;/em&gt;,
are the well-known defaults in Raspbian. Let's go ahead and change
them.&lt;/p&gt;
&lt;p&gt;The relevant lines in the script look like this:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-1"&gt;&lt;/a&gt;on_chroot &lt;span class="s"&gt;&amp;lt;&amp;lt; EOF&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-2"&gt;&lt;/a&gt;&lt;span class="s"&gt;if ! id -u pi &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-3"&gt;&lt;/a&gt;&lt;span class="s"&gt;     adduser --disabled-password --gecos "" pi&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-4"&gt;&lt;/a&gt;&lt;span class="s"&gt;fi&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-5"&gt;&lt;/a&gt;&lt;span class="s"&gt;echo "pi:raspberry" | chpasswd&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-6"&gt;&lt;/a&gt;&lt;span class="s"&gt;echo "root:root" | chpasswd&lt;/span&gt;
&lt;a name="rest_code_cd582d3a7569473994dbeeacebcbea94-7"&gt;&lt;/a&gt;&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The user pi is created with the line
&lt;code class="shell"&gt;adduser --disabled-password --gecos &lt;span class="s2"&gt;""&lt;/span&gt; pi&lt;/code&gt; if it doesn't
already exist. According to the &lt;a class="reference external" href="http://manpages.ubuntu.com/manpages/trusty/man8/adduser.8.html"&gt;adduser man pages&lt;/a&gt;
The --disabled-password flag prevents the program passwd from setting
the account's password when adduser is run, but remote logins without
password authentication to the pi account are still allowed. the
&lt;code class="shell"&gt;--gecos &lt;span class="s2"&gt;""&lt;/span&gt;&lt;/code&gt; flag simply adds an empty string to the
/etc/passwd file for the pi account.&lt;/p&gt;
&lt;p&gt;After the user is created, &lt;em&gt;raspberry&lt;/em&gt; is set as pi's password and
&lt;em&gt;root&lt;/em&gt; is set as the root password in the lines &lt;code class="shell"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt;
&lt;span class="s2"&gt;"pi:raspberry"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; chpasswd&lt;/code&gt; and &lt;code class="shell"&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"root:root"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; chpasswd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's start by modifying the pi account. For the sake of this example,
let's change its name to alphapi. For the password, we will generate a
&lt;strong&gt;temporary, random&lt;/strong&gt; password and write it to a file in the deploy
directory. We'll do the same for root. The modifications look like the
following:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;user_passwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&amp;lt; /dev/urandom tr -dc _A-Z-a-z-0-9 &lt;span class="p"&gt;|&lt;/span&gt; head -c&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;8&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-2"&gt;&lt;/a&gt;&lt;span class="nv"&gt;root_passwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&amp;lt; /dev/urandom tr -dc _A-Z-a-z-0-9 &lt;span class="p"&gt;|&lt;/span&gt; head -c&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;8&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-3"&gt;&lt;/a&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Write passwords to a file.&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-5"&gt;&lt;/a&gt;cat &lt;span class="s"&gt;&amp;lt;&amp;lt;EOF &amp;gt; /pi-gen/deploy/users&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-6"&gt;&lt;/a&gt;&lt;span class="s"&gt;${user_passwd}&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-7"&gt;&lt;/a&gt;&lt;span class="s"&gt;${root_passwd}&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-8"&gt;&lt;/a&gt;&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-10"&gt;&lt;/a&gt;on_chroot &lt;span class="s"&gt;&amp;lt;&amp;lt; EOF&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-11"&gt;&lt;/a&gt;&lt;span class="s"&gt;if ! id -u alphapi &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-12"&gt;&lt;/a&gt;&lt;span class="s"&gt;     adduser --disabled-password --gecos "" alphapi&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-13"&gt;&lt;/a&gt;&lt;span class="s"&gt;fi&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-14"&gt;&lt;/a&gt;&lt;span class="s"&gt;echo "alphapi:${user_passwd}" | chpasswd&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-15"&gt;&lt;/a&gt;&lt;span class="s"&gt;echo "root:${root_passwd}" | chpasswd&lt;/span&gt;
&lt;a name="rest_code_5cd7b9791db443d7bec97144b91014aa-16"&gt;&lt;/a&gt;&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The first two lines create random alphanumeric passwords for the users
alphapi and root. They should be changed immediately when the image is
first run.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_860ca64fd41c48279dd0670a488e98f4-1"&gt;&lt;/a&gt;&lt;span class="nv"&gt;user_passwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&amp;lt; /dev/urandom tr -dc _A-Z-a-z-0-9 &lt;span class="p"&gt;|&lt;/span&gt; head -c&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;8&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;a name="rest_code_860ca64fd41c48279dd0670a488e98f4-2"&gt;&lt;/a&gt;&lt;span class="nv"&gt;root_passwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&amp;lt; /dev/urandom tr -dc _A-Z-a-z-0-9 &lt;span class="p"&gt;|&lt;/span&gt; head -c&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;8&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;This way of password generation works by reading random bytes from
/dev/urandom and redirecting them to the standard input of the tr
command, which filters the input so only alphanumeric characters
remain. Next, the output is piped to the head command, which outputs
only the first eight alphanumeric characters produced in this fashion.&lt;/p&gt;
&lt;p&gt;The passwords are then written to a file named &lt;strong&gt;users&lt;/strong&gt; inside the
deploy directory where the outputs will eventually be placed.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_31f3864808ed4da2a89d0f76ebd492ff-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Write passwords to a file.&lt;/span&gt;
&lt;a name="rest_code_31f3864808ed4da2a89d0f76ebd492ff-2"&gt;&lt;/a&gt;cat &lt;span class="s"&gt;&amp;lt;&amp;lt;EOF &amp;gt; /pi-gen/deploy/users&lt;/span&gt;
&lt;a name="rest_code_31f3864808ed4da2a89d0f76ebd492ff-3"&gt;&lt;/a&gt;&lt;span class="s"&gt;${user_passwd}&lt;/span&gt;
&lt;a name="rest_code_31f3864808ed4da2a89d0f76ebd492ff-4"&gt;&lt;/a&gt;&lt;span class="s"&gt;${root_passwd}&lt;/span&gt;
&lt;a name="rest_code_31f3864808ed4da2a89d0f76ebd492ff-5"&gt;&lt;/a&gt;&lt;span class="s"&gt;EOF&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The remaining parts of the script are more-or-less the same as before,
except I changed pi to alphapi and used variable substitution for the
passwords.&lt;/p&gt;
&lt;p&gt;Running ./build-docker.sh at this point will raise an error in stage02
because it's at this stage where the user pi is added to the various
groups on the system. We therefore need to open
&lt;strong&gt;stage2/01-sys-tweaks/01-run.sh&lt;/strong&gt; and modify the following lines,
replacing pi with alphapi.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_aab65eb2dfdb4682bcc8b2c194f70c65-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;for&lt;/span&gt; GRP in adm dialout cdrom audio users sudo video games plugdev input gpio spi i2c netdev&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
&lt;a name="rest_code_aab65eb2dfdb4682bcc8b2c194f70c65-2"&gt;&lt;/a&gt;    adduser alphapi &lt;span class="nv"&gt;$GRP&lt;/span&gt;
&lt;a name="rest_code_aab65eb2dfdb4682bcc8b2c194f70c65-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="set-the-locale-information"&gt;
&lt;h3&gt;Set the locale information&lt;/h3&gt;
&lt;p&gt;The locale information used by your operating system may be modified
as follows. Open &lt;strong&gt;stage0/01-locale/00-debconf&lt;/strong&gt;. I personally changed
every occurence of en_GB.UTF-8 to en_US.UTF-8, but you can set your
locale accordingly.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Locales to be generated:&lt;/span&gt;
&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Choices: All locales, aa_DJ ISO-8859-1, aa_DJ.UTF-8 UTF-8, ...&lt;/span&gt;
&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-3"&gt;&lt;/a&gt;locales locales/locales_to_be_generated multiselect en_US.UTF-8 UTF-8
&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Default locale for the system environment:&lt;/span&gt;
&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Choices: None, C.UTF-8, en_US.UTF-8&lt;/span&gt;
&lt;a name="rest_code_84cf504b872149b386a697ea53332dce-6"&gt;&lt;/a&gt;locales locales/default_environment_locale   &lt;span class="k"&gt;select&lt;/span&gt;  en_US.UTF-8
&lt;/pre&gt;&lt;p&gt;Next, we open &lt;strong&gt;stage2/01-sys-tweaks/00-debconf&lt;/strong&gt;. I currently live in
Europe, so I made the following changes:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tzdata        tzdata/Areas    select  Europe
&lt;/pre&gt;
&lt;p&gt;I also made the following changes to switch from the default British
English to American English:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_75299cf5cb064bad80bc9e35a0f143ae-1"&gt;&lt;/a&gt;keyboard-configuration keyboard-configuration/xkb-keymap &lt;span class="k"&gt;select&lt;/span&gt; us
&lt;a name="rest_code_75299cf5cb064bad80bc9e35a0f143ae-2"&gt;&lt;/a&gt;keyboard-configuration keyboard-configuration/fvariant  &lt;span class="k"&gt;select&lt;/span&gt;  English &lt;span class="o"&gt;(&lt;/span&gt;US&lt;span class="o"&gt;)&lt;/span&gt; - English &lt;span class="o"&gt;(&lt;/span&gt;US&lt;span class="se"&gt;\,&lt;/span&gt; international with dead keys&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Note that the comment in 00-debconf above the
keyboard-configuration/xkb-keymap line erroneously states that
American English is an option, but it's not. You need to change it
from "gb" to "us" if you want the American layout.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="using-the-custom-image"&gt;
&lt;h2&gt;Using the custom image&lt;/h2&gt;
&lt;p&gt;With all these changes, we can build our new image by running
&lt;code class="shell"&gt;./build-docker.sh&lt;/code&gt; and, if successful, find a .zip file inside
the deploy directory with the image name and date.&lt;/p&gt;
&lt;p&gt;To use this image, we unzip the file to extract the .img file inside
it. Next, we need to copy it onto a SD card that will plug into the
pi. I have a SD card reader/writer on my laptop for which I check for
its Linux device name by running &lt;code class="shell"&gt;lsblk&lt;/code&gt; before and after
plugging in the card. (The device that appears in the output of lsblk
after plugging it in is its name, which is &lt;strong&gt;/dev/mmcblk0&lt;/strong&gt; on my
laptop). Once I get its device name, I use the Linux &lt;code class="shell"&gt;dd&lt;/code&gt;
command to copy the contents of the image onto the card. (Be sure to
change /dev/mccblk0 to match the name that your system gives to your
SD card device.)&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_2118ddc82cbf42cf9b0d6ae1f931e4fa-1"&gt;&lt;/a&gt;sudo dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2018&lt;/span&gt;-07-21-my_name-lite.img &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/mmcblk0 &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; sync
&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Please be EXTREMELY careful that you get the device name right.&lt;/strong&gt;
It's not very difficult to write the contents of the image file over
your root partition or other important data.&lt;/p&gt;
&lt;p&gt;After writing the image, we can plug the SD card into our pi, boot it
up, and try logging in as alphapi with the random password that was
created in the users file. &lt;strong&gt;Be sure at this point to change your
user's and root's password&lt;/strong&gt;. We can also verify that the keyboard was
set to US English by typing Shift-3 and observing whether we get a
hashtag (#) symbol and not the symbol for the British pound currency.&lt;/p&gt;
&lt;p&gt;In a follow-up post, I will describe how to setup the network and SSH
so I can continue to setup my Raspberry Pi without ever needing a
terminal.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>devops</category><category>raspberry pi</category><category>raspbian</category><guid>http://kmdouglass.github.io/posts/create-a-custom-raspbian-image-with-pi-gen-part-1/</guid><pubDate>Sat, 21 Jul 2018 10:31:28 GMT</pubDate></item><item><title>How I built a cross-compilation workflow for the Raspberry Pi</title><link>http://kmdouglass.github.io/posts/how-i-built-a-cross-compilation-workflow-for-the-raspberry-pi/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;Some of you may know I tinker with the Raspberry Pi in my free time
and that one of my current projects is to build a lensless microscope
with the Pi as the brains. To control the microscope, I decided a
while ago that I would use &lt;a class="reference external" href="https://micro-manager.org/wiki/Micro-Manager"&gt;Micro-Manager&lt;/a&gt;, an open-source
software package for microscope control. I made this decision for a
few reasons:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;I already knew the Micro-Manager codebase since I use it frequently
at work.&lt;/li&gt;
&lt;li&gt;The Micro-Manager core provides a device-independent interface to
hardware.&lt;/li&gt;
&lt;li&gt;I've contributed to the project in the past and feel a sense of
loyalty to the project and the people involved. Expanding
Micro-Manager into embedded microscopy would be a great way for me
to give back to the community.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Building Micro-Manager from source code presents its own set of
challenges. After ensuring that you have the correct build
environment, you need to actually compile it, and here's where things
get tricky in Raspyberry Pi development. The Pi has an ARM processor,
whereas most laptops and workstations use a x86_64 processor. This
means that code compiled on a typical desktop PC will not work on the
Pi. As I showed in &lt;a class="reference external" href="https://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi.html"&gt;my earlier post&lt;/a&gt;,
you can compile the code directly on the Pi to circumvent this, but
this unfortunately is quite cumbersome because the code base and
dependencies are quite large. (They are nearly 8 GB in
total). Furthermore, compiling the project on the Pi is slow and
requires connecting to it via ssh or working directly on a TV screen
or monitor.&lt;/p&gt;
&lt;p&gt;These problems extend beyond Micro-Manager to other large-scale
projects that require code compilation for a specific processor
architecture. In this post, I'll describe the workflow that I
developed for cross-compiling projects for the Raspberry Pi.&lt;/p&gt;
&lt;div class="section" id="previous-attempts"&gt;
&lt;h2&gt;Previous attempts&lt;/h2&gt;
&lt;p&gt;Prior to the workflow that is the main topic of this post, I managed
to cross-compile Micro-Manager using a &lt;cite&gt;chroot&lt;/cite&gt; environment and the
&lt;a class="reference external" href="https://www.qemu.org/"&gt;QEMU emulator&lt;/a&gt;. &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Chroot"&gt;chroot&lt;/a&gt; is a Linux command that
changes the apparent root (or '/') directory for a running
process. With this approach, I mount an image of the &lt;a class="reference external" href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian
operating system&lt;/a&gt;
that contains the gcc and g++ compilers and libraries for the ARM
architecture. Then, I chroot into the image and run a setup script
that builds the software. During execution of this script, the QEMU
static libraries run the ARM compilers from within the chroot
environment to build the project. The compiled code remains inside the
image, which I then burn onto a micro SD card to insert into the Pi. I
uploaded &lt;a class="reference external" href="https://gist.github.com/kmdouglass/38e1383c7e62745f3cf522702c21cb49"&gt;a gist of the bash script&lt;/a&gt;
which orchestrates all this, and my inspiration for this approach came
from a great series of blog posts from &lt;a class="reference external" href="https://disconnected.systems/blog/custom-rpi-image-with-github-travis/"&gt;Disconnected Systems&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately this approach is a huge amount of work. As you can see in
the gist, it's fairly complicated bash scripting that's not easy to
debug. Furthermore, the setup script that is run inside the image
needs to do a lot of work beyond cross-compiling, like setting up the
user, permissions, network, etc. Debugging the final product is also a
challenge because you need to verify that it's working on the Pi,
which requires burning the image to a micro SD card.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cross-compiling-with-docker"&gt;
&lt;h2&gt;Cross-compiling with Docker&lt;/h2&gt;
&lt;p&gt;After a bit of research I decided I would try instead to use &lt;a class="reference external" href="https://www.docker.com/"&gt;Docker&lt;/a&gt; for cross-compilation and deployment to
the Pi. I had just started using Docker at work to build reproducible
environments for scientific computing research. In particular, and
unlike my chroot script, I had learned that a Docker container that
built the project could work on nearly any system that had Docker
installed. Furthermore, deploying updates can be done on any Raspberry
Pi that's running Docker.&lt;/p&gt;
&lt;p&gt;I liked the idea of a portable cross-compilation workflow, so I dove
into the Docker documentation and managed to get everything working in
a few weeks of tinkering at home.&lt;/p&gt;
&lt;div class="section" id="an-overview-of-docker"&gt;
&lt;h3&gt;An overview of Docker&lt;/h3&gt;
&lt;p&gt;You can find many resources online about Docker, so I won't go into
the details here. The main thing you need to know is that Docker is a
system for creating, running, and sharing &lt;em&gt;containers&lt;/em&gt;, which are
something like light weight virtual machines. Containers solve the
problem in software development of how to build and deploy programs
that have a complex set of dependencies. It does this by isolating the
environment in which a program runs from the rest of the operating
system. For example, if you have a computer that has a certain version
of gcc (the GNU C compiler) installed, but your application requires a
different version, then you can install the required gcc along with
your application inside a container and they will not interfere with
the version of gcc that belongs to your operating system. This also
means that you can send your container to any machine that has Docker
installed and it should just run without having to do any setup.&lt;/p&gt;
&lt;p&gt;Other important things to know about Docker are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;There are two main types of objects: images and containers. Images
are sort of like blueprints that define what is inside a container,
whereas containers are like the actual buildings specified by the
blueprints. There can be many containers that come from a single
image.&lt;/li&gt;
&lt;li&gt;Containers are meant to be immutable. When you stop them and restart
them, they always restart in the same state as when they were first
created.&lt;/li&gt;
&lt;li&gt;Since containers are immutable, some of your application data may
need to be placed in a volume, which is either another container or
a folder on the host system. A volume gets connected to your
application container and exists even when your application
container is not running.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="the-cross-compilation-workflow"&gt;
&lt;h2&gt;The cross-compilation workflow&lt;/h2&gt;
&lt;p&gt;Now that we have established the essential background to this project,
let's look at the cross-compilation workflow. Below is a picture that
provides a sense of the entire process, moving in general from
left-to-right.&lt;/p&gt;
&lt;img alt="The cross-compilation workflow" class="align-center" src="http://kmdouglass.github.io/images/mm_docker_workflow.png"&gt;
&lt;p&gt;The process involves two Docker containers: one for building
Micro-Manager and the other for running the application. The build
dependencies and the QEMU emulator are both located inside the build
container, having been specified when its image was created. These
allow us to compile Micro-Manager for the ARM architecture.  The
source code is connected to the build container as a &lt;em&gt;bind mount&lt;/em&gt;,
which is a folder from the host workstation that is mounted inside the
build container when it is run.&lt;/p&gt;
&lt;p&gt;Once the libraries are compiled, they are installed into a folder
inside the bind mount so that the host system will have access to them
after the build container closes. Next, the compiled libraries are
copied directly into an image that defines the application
container. This image defines only the essential run-time requirements
for running Micro-Manager and nothing else. The application image is
stored on the registry server which I set up on my local network. This
makes it easy for the Raspberry Pi to download the latest image and
run the Micro-Manager application container whenever I make changes.&lt;/p&gt;
&lt;p&gt;An important aspect of this workflow is how the data is passed between
the systems and containers. Unlike what you will find in many
introductory tutorials on Docker, I do not add the Micro-Manager
source code directly to the build image/containers but instead use a
bind mount. The reason for this is that the source code and 3rd party
libraries are quite large, about 8 GB in total. By using a bind mount,
I avoid needless copying of this data. Another reason for using a bind
mount is that the source code will change frequently during
development. If I add the source code to the image, then I will have
to recreate the image every time the source code changes.&lt;/p&gt;
&lt;p&gt;Once the libraries are built, I directly copy them into the
application image because they are much, much smaller than the source
code. I also want the code stored directly in the image so that the
application image is all the Raspberry Pi needs to run the
program. The image is stored in my local &lt;a class="reference external" href="https://docs.docker.com/registry/"&gt;Docker registry&lt;/a&gt; server so that once I push an
updated image to the server, the Raspberry Pi can download it and use
it immediately.&lt;/p&gt;
&lt;div class="section" id="step-0-prerequisites"&gt;
&lt;h3&gt;Step 0: Prerequisites&lt;/h3&gt;
&lt;p&gt;I am going to assume that you already have installed Docker. (If not,
follow &lt;a class="reference external" href="https://docs.docker.com/install/"&gt;these directions&lt;/a&gt;.) I am
also going to assume that you are somewhat familiar with how to work
on a Linux system. The Raspberry Pi runs Linux, so you probably
wouldn't be here if you didn't already know at least a little.&lt;/p&gt;
&lt;p&gt;For this article, I am working with these versions of Docker and
Ubuntu on my host workstation.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~$ uname -a
Linux xxxxx 4.13.0-39-generic #44~16.04.1-Ubuntu SMP Thu Apr 5 16:43:10 UTC 2018 x86_64 x86_64
x86_64 GNU/Linux

kmdouglass@xxxxx:~$ docker version
Client:
 Version:      18.03.1-ce
 API version:  1.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Thu Apr 26 07:17:20 2018
 OS/Arch:      linux/amd64
 Experimental: false
 Orchestrator: swarm

Server:
 Engine:
  Version:      18.03.1-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.5
  Git commit:   9ee9f40
  Built:        Thu Apr 26 07:15:30 2018
  OS/Arch:      linux/amd64
  Experimental: false
&lt;/pre&gt;
&lt;p&gt;Finally, below is how my project directory structure is laid out.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker$ tree -L 2
.
└── rpi-micromanager
    ├── 2.0-python
    │   ├── build
    │   └── Dockerfile
    └── build
        ├── build
        ├── Dockerfile
        ├── run
        └── setup
&lt;/pre&gt;
&lt;p&gt;I have two folders; build, which contains the files for the build
container, and 2.0-python, which contains the files for creating the
Micro-Manager application container. (In my case, I am going to build
the Python wrapper for Micro-Manager 2.0.) Inside each folder are the
scripts and Dockerfiles that execute the various steps of the
workflow.&lt;/p&gt;
&lt;p&gt;The final prerequisite is to register QEMU with the Docker build
agent. First, install a few packages for QEMU. On Ubuntu, this looks
like&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f4df6f5a58624db7bd618e7c93225e89-1"&gt;&lt;/a&gt;$ sudo apt update
&lt;a name="rest_code_f4df6f5a58624db7bd618e7c93225e89-2"&gt;&lt;/a&gt;$ sudo install qemu qemu-user-static qemu-user binfmt-support
&lt;/pre&gt;&lt;p&gt;Finally, register the build agent with the command:&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c7b127b355764bdb84de753bd0d0536a-1"&gt;&lt;/a&gt;$ docker run --rm --privileged multiarch/qemu-user-static:register --reset
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="step-1-create-the-build-image"&gt;
&lt;h3&gt;Step 1: Create the build image&lt;/h3&gt;
&lt;p&gt;Inside the build folder, I have a file called Dockerfile. Here are its
contents.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Defines a build environment for Micro-Manager on the Raspberry Pi.&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: docker build \&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          -t NAME:TAG \&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#         .&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-10"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-11"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-13"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-start"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Get the build dependencies.&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-16"&gt;&lt;/a&gt;RUN apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get -y install --no-install-recommends &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-17"&gt;&lt;/a&gt;autoconf &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-18"&gt;&lt;/a&gt;automake &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-19"&gt;&lt;/a&gt;build-essential &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-20"&gt;&lt;/a&gt;git &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-21"&gt;&lt;/a&gt;libatlas-base-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-22"&gt;&lt;/a&gt;libboost-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-23"&gt;&lt;/a&gt;libboost-all-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-24"&gt;&lt;/a&gt;libtool &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-25"&gt;&lt;/a&gt;patch &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-26"&gt;&lt;/a&gt;pkg-config &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-27"&gt;&lt;/a&gt;python3-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-28"&gt;&lt;/a&gt;python3-pip &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-29"&gt;&lt;/a&gt;python3-setuptools &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-30"&gt;&lt;/a&gt;python3-wheel &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-31"&gt;&lt;/a&gt;swig &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-32"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/* &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-33"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; pip3 install numpy
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-34"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-35"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-end"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-36"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-37"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Set up the mount point for the source files and setup script.&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-38"&gt;&lt;/a&gt;ADD setup /micro-manager/
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-39"&gt;&lt;/a&gt;VOLUME /micro-manager/src
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-40"&gt;&lt;/a&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-41"&gt;&lt;/a&gt;WORKDIR /micro-manager/src
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-42"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_1f7fe8b4f7434cc9a1f1cc100d44dec2-43"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/micro-manager/setup"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;A Dockerfile defines the steps in building an image -- in this case,
the build image. Let's break this file down into pieces. In the first
two lines that follow the comments, I specify that my image is based
on the resin/raspberrypi3-debian:stretch image and that I am the
maintainer.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_5910ede5f135467cb5f1f036a00d6691-1"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_5910ede5f135467cb5f1f036a00d6691-2"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;/pre&gt;&lt;p&gt;Images from &lt;a class="reference external" href="https://hub.docker.com/u/resin/"&gt;Resin&lt;/a&gt; are freely
available and already have the QEMU emulator installed. Next, I
specify what commands should be run for the ARM architecture. Any
commands located between &lt;tt class="docutils literal"&gt;RUN [ &lt;span class="pre"&gt;"cross-build-start"&lt;/span&gt; ]&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;RUN [
&lt;span class="pre"&gt;"cross-build-end"&lt;/span&gt; ]&lt;/tt&gt; will be run using the emulator. Inside these two
commands, I install the build dependencies for Micro-Manager using
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;apt-get&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pip&lt;/tt&gt;. (These are just standard commands for
installing software on Debian/Ubuntu Linux machines and from PyPI,
respectively.)&lt;/p&gt;
&lt;p&gt;After the installation of the requirements completes, I add the setup
script to the folder /micro-manager inside the image with the &lt;tt class="docutils literal"&gt;ADD
setup &lt;span class="pre"&gt;/micro-manager/&lt;/span&gt;&lt;/tt&gt; command. The setup script contains the
commands that will actually compile Micro-Manager. I then define a
mount point for the source code with &lt;tt class="docutils literal"&gt;VOLUME
&lt;span class="pre"&gt;/micro-manager/src&lt;/span&gt;&lt;/tt&gt;. &lt;strong&gt;It's important to realize here that you do not
mount volumes inside images, you mount volumes inside containers.&lt;/strong&gt;
This command is just telling the image to expect a folder to be
mounted at this location when the container is run.&lt;/p&gt;
&lt;p&gt;The last three lines set the working directory, the entrypoint and the
default container command, respectively.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_92c7502ee22944f987eec8edaaa0a343-1"&gt;&lt;/a&gt;WORKDIR /micro-manager/src
&lt;a name="rest_code_92c7502ee22944f987eec8edaaa0a343-2"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_92c7502ee22944f987eec8edaaa0a343-3"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"/micro-manager/setup"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;This specific entrypoint tells Docker that any containers built from
this image should first run Tini, which is a lightweight init system
for Docker containers. If you do not specify Tini as the entry point,
then it will not be able to reap zombies. (I don't know what this
means exactly, but it sounds cool and you can read about it here:
&lt;a class="reference external" href="https://github.com/krallin/tini"&gt;https://github.com/krallin/tini&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;By default, the container will run the setup script, but, since I used
the &lt;tt class="docutils literal"&gt;CMD&lt;/tt&gt; directive, this can be overriden in case we need to
perform some manual steps. Roughly speaking, you can think of the
entrypoint as the command that can not be overridden and the CMD
command as the one that can be. In other words, Tini will always be
executed when containers created from this image are launched, whereas
you can choose not to run the setup script but instead to enter the
container through a Bash shell, for example.&lt;/p&gt;
&lt;p&gt;To build the image, I use the following build script located in the
same directory as the Dockerfile for convenience.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./build&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-6"&gt;&lt;/a&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-7"&gt;&lt;/a&gt;docker build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-8"&gt;&lt;/a&gt;       -t localhost:5000/rpi-micromanager:build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c62e1bf9d8754811a58ee084b140144c-9"&gt;&lt;/a&gt;       .
&lt;/pre&gt;&lt;p&gt;By using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt; &lt;span class="pre"&gt;localhost:5000/rpi-micromanager:build&lt;/span&gt;&lt;/tt&gt; argument I am
giving the image a name of &lt;em&gt;rpi-micromanager&lt;/em&gt;, a tag of &lt;em&gt;build&lt;/em&gt;, and
specifying that I will eventually host this image on my local registry
server (localhost) on port 5000.&lt;/p&gt;
&lt;p&gt;In case you are wondering about the contents of the setup script,
don't worry. I'll explain it in the next section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-2-compile-micro-manager"&gt;
&lt;h3&gt;Step 2: Compile Micro-Manager&lt;/h3&gt;
&lt;p&gt;After the image is built, I create a container and use it to compile
Micro-Manager. For this, I use the run script in the build directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./run DIR CONFIGURE&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# DIR is the parent folder containing the micro-manager Git&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# repository, the 3rdpartypublic Subversion repository, and any&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# additional build resources.&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-9"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-10"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# If CONFIGURE=true, the build system is remade and the configure&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-11"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# script is rerun before running 'make' and 'make install'. If&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-12"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# CONFIGURE=false, only 'make' and 'make install' are run.&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-13"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-14"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# The compiled program files are stored in a bind mount volume so that&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# they may be copied into the deployment container.&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-16"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-17"&gt;&lt;/a&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-18"&gt;&lt;/a&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-19"&gt;&lt;/a&gt;&lt;span class="nv"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/micro-manager/setup &lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-20"&gt;&lt;/a&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-21"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Remove the build artifacts from previous builds.&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-22"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-23"&gt;&lt;/a&gt;    rm -rf &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/build &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-24"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-25"&gt;&lt;/a&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-26"&gt;&lt;/a&gt;docker run --rm &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-27"&gt;&lt;/a&gt;       -v &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;:/micro-manager/src &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-28"&gt;&lt;/a&gt;       --name mm-build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-29"&gt;&lt;/a&gt;       localhost:5000/rpi-micromanager:build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_6f72e78cdbe64102b8bb5cf3cdef80f3-30"&gt;&lt;/a&gt;       &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;cmd&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The script takes two arguments. The first is the path to the folder
containing all the source code (see below for details). The second
argument is either &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;. (It can actually be
anything, but it will only compile Micro-Manager if either &lt;strong&gt;true&lt;/strong&gt; or
&lt;strong&gt;false&lt;/strong&gt; are provided.) If true, the full build process is run,
including setting up the configure script; if false, only make and
make install are run, which should recompile and install only recently
updated files.&lt;/p&gt;
&lt;p&gt;The run script uses the -v argument to &lt;tt class="docutils literal"&gt;docker run&lt;/tt&gt; to mount the
source directory into the container at the point specified by the
&lt;tt class="docutils literal"&gt;VOLUME&lt;/tt&gt; command in the Dockerfile. The directory layout on my host
file system for the source directory looks like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:/media/kmdouglass/Data/micro-manager$ tree -L 1
.
├── 3rdpartypublic
├── micro-manager
└── patches
&lt;/pre&gt;
&lt;p&gt;The patches folder is not necessary and only there to fix &lt;a class="reference external" href="https://github.com/micro-manager/micro-manager/pull/613"&gt;a bug&lt;/a&gt; in the
WieneckeSinscke device adapter. (This bug may be fixed by now.)
3rdpartypublic is the large Subversion repository of all the required
software to build Micro-Manager, and micro-manager is the &lt;a class="reference external" href="https://github.com/micro-manager/micro-manager"&gt;cloned
GitHub repository&lt;/a&gt;. Prior to building,
I checkout the mm2 branch because I am interested in developing my
application for Micro-Manager 2.0.&lt;/p&gt;
&lt;p&gt;The setup script that is run inside the container and mentioned in the
previous section looks like this.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# # Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Builds Micro-Manager.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./setup CONFIGURE&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-9"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# If CONFIGURE=true, the build system is remade and the configure&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-10"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# script is rerun before running 'make' and 'make install'. If&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-11"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# CONFIGURE=false, only 'make' and 'make install' or run.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-12"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-13"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Kyle M. Douglass, 2018&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-14"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-15"&gt;&lt;/a&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-16"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Move into the source directory.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-17"&gt;&lt;/a&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; micro-manager
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-18"&gt;&lt;/a&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-19"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Undo any previous patches.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-20"&gt;&lt;/a&gt;git checkout -- DeviceAdapters/WieneckeSinske/CAN29.cpp
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-21"&gt;&lt;/a&gt;git checkout -- DeviceAdapters/WieneckeSinske/WieneckeSinske.cpp
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-22"&gt;&lt;/a&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-23"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Patch the broken WieneckeSinske device adapter.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-24"&gt;&lt;/a&gt;patch DeviceAdapters/WieneckeSinske/CAN29.cpp &amp;lt; ../patches/CAN29.cpp.diff &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-25"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; patch DeviceAdapters/WieneckeSinske/WieneckeSinske.cpp &amp;lt; ../patches/WieneckeSinske.cpp.diff
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-26"&gt;&lt;/a&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-27"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Compile MM2.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-28"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-29"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# Remake the entire build system, then compile from scratch.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-30"&gt;&lt;/a&gt;    ./autogen.sh
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-31"&gt;&lt;/a&gt;    &lt;span class="nv"&gt;PYTHON&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/bin/python3"&lt;/span&gt; ./configure &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-32"&gt;&lt;/a&gt;        --prefix&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/micro-manager/src/build"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-33"&gt;&lt;/a&gt;        --with-python&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/include/python3.5"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-34"&gt;&lt;/a&gt;        --with-boost-libdir&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/lib/arm-linux-gnueabihf"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-35"&gt;&lt;/a&gt;        --with-boost&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/usr/include/boost"&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-36"&gt;&lt;/a&gt;        --disable-java-app &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-37"&gt;&lt;/a&gt;        --disable-install-dependency-jars &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-38"&gt;&lt;/a&gt;        --with-java&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"no"&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-39"&gt;&lt;/a&gt;    make
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-40"&gt;&lt;/a&gt;    make install
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-41"&gt;&lt;/a&gt;    chmod -R a+w /micro-manager/src/build
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-42"&gt;&lt;/a&gt;&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-43"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# Only recompile changed source files.&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-44"&gt;&lt;/a&gt;    make
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-45"&gt;&lt;/a&gt;    make install
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-46"&gt;&lt;/a&gt;    chmod -R a+w /micro-manager/src/build
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-47"&gt;&lt;/a&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-48"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt; : Unrecognized argument."&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-49"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Pass \"true\" to run the full build process."&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-50"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Pass \"false\" to run only \"make\" and \"make install\"."&lt;/span&gt;
&lt;a name="rest_code_966c46d1e02e4ed9916f4d37b690b07c-51"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Most important in this script is the call to &lt;tt class="docutils literal"&gt;configure&lt;/tt&gt;. You can
see that the compiled libraries and Python wrapper will be written to
the build folder inside the mounted directory. This gives the host
file system access to the compiled artifacts after the container has
stopped.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-3-build-the-application-image"&gt;
&lt;h3&gt;Step 3: Build the application image&lt;/h3&gt;
&lt;p&gt;Once the libraries are compiled, we can add them to an application
image that contains only the essentials for running Micro-Manager.&lt;/p&gt;
&lt;p&gt;For this, I use a separate Dockerfile inside the 2.0-python
directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Builds the Micro-Manager 2.0 Python wrapper for the Raspberry Pi.&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: docker build \&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          -t NAME:TAG \&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#          .&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-10"&gt;&lt;/a&gt;FROM resin/raspberrypi3-debian:stretch
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-11"&gt;&lt;/a&gt;MAINTAINER Kyle M. Douglass &amp;lt;kyle.m.douglass@gmail.com&amp;gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-12"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-13"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-start"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Install the run-time dependencies.&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-16"&gt;&lt;/a&gt;RUN apt-get update &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get -y install --no-install-recommends &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-17"&gt;&lt;/a&gt;    libatlas-base-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-18"&gt;&lt;/a&gt;    libboost-all-dev &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-19"&gt;&lt;/a&gt;    python3-pip &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-20"&gt;&lt;/a&gt;    python3-setuptools &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-21"&gt;&lt;/a&gt;    python3-wheel &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-22"&gt;&lt;/a&gt;    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; pip3 install numpy &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-23"&gt;&lt;/a&gt;    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-24"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-25"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copy in the Micro-Manager source files.&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-26"&gt;&lt;/a&gt;RUN useradd -ms /bin/bash micro-manager
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-27"&gt;&lt;/a&gt;WORKDIR /home/micro-manager/app
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-28"&gt;&lt;/a&gt;COPY --chown&lt;span class="o"&gt;=&lt;/span&gt;micro-manager:micro-manager . .
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-29"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-30"&gt;&lt;/a&gt;RUN &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;"cross-build-end"&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-31"&gt;&lt;/a&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-32"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Final environment configuration.&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-33"&gt;&lt;/a&gt;USER micro-manager:micro-manager
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-34"&gt;&lt;/a&gt;ENV PYTHONPATH /home/micro-manager/app/lib/micro-manager
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-35"&gt;&lt;/a&gt;ENTRYPOINT &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/sbin/tini"&lt;/span&gt;, &lt;span class="s2"&gt;"-s"&lt;/span&gt;, &lt;span class="s2"&gt;"--"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;a name="rest_code_46b4c349fe104918b102ca6087ee7b15-36"&gt;&lt;/a&gt;CMD &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"/usr/bin/python3"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;As before, I use a clean resin base image. However, this time I only
install the essential software to run Micro-Manager.&lt;/p&gt;
&lt;p&gt;After apt-getting and pip-installing everything, I create a new user
called &lt;strong&gt;micro-manager&lt;/strong&gt; and a new folder called &lt;strong&gt;app&lt;/strong&gt; inside this
user's home directory.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c9363b3dfe7c48a3afa05fa732537cd8-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copy in the Micro-Manager source files.&lt;/span&gt;
&lt;a name="rest_code_c9363b3dfe7c48a3afa05fa732537cd8-2"&gt;&lt;/a&gt;RUN useradd -ms /bin/bash micro-manager
&lt;a name="rest_code_c9363b3dfe7c48a3afa05fa732537cd8-3"&gt;&lt;/a&gt;WORKDIR /home/micro-manager/app
&lt;/pre&gt;&lt;p&gt;Next, I directly copy the compiled libraries into the image with the
COPY command.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f199dbee693647feb0ce94d6a1dcb64a-1"&gt;&lt;/a&gt;COPY --chown&lt;span class="o"&gt;=&lt;/span&gt;micro-manager:micro-manager . .
&lt;/pre&gt;&lt;p&gt;The two periods (.) mean that I copy the current host directory's
contents into the container's current working directory
(/home/micro-manager/app). What is the current host directory? Well,
as I explain below, I actually run this Dockerfile from inside the
&lt;strong&gt;build&lt;/strong&gt; folder that was created to hold the compiled libraries in
the previous step. But first, I'll end my explanation of the
Dockerfile by saying that I switch the USER so that I do not run the
container as root, add the library to the PYTHONPATH environment
variable, and setup the default command as the python3 interpreter.&lt;/p&gt;
&lt;p&gt;To build this image, I use the following build script.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-2"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Copyright (C) 2018 Kyle M. Douglass&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-3"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-4"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Usage: ./build DIR&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-5"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-6"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# DIR is the root directory containing the Micro-Manager build&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# artifacts. These artifacts will be added to the Docker image.&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-10"&gt;&lt;/a&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-12"&gt;&lt;/a&gt;cp Dockerfile &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-13"&gt;&lt;/a&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-15"&gt;&lt;/a&gt;docker build &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-16"&gt;&lt;/a&gt;       -t localhost:5000/rpi-micromanager:2.0-python &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_c54f777de08141208482d2bd59e0c1ae-17"&gt;&lt;/a&gt;       .
&lt;/pre&gt;&lt;p&gt;This script takes one argument, which is the &lt;strong&gt;build&lt;/strong&gt; directory
containing the compiled source code. The script first copies the
Dockerfile into this directory and then changes into it with the cd
command. (This explains the two periods (.) in the COPY command in the
Dockerfile.)&lt;/p&gt;
&lt;p&gt;Finally, I build the image and give it a name of
localhost:5000/rpi-micromanager:2.0-python.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-4-add-the-image-to-the-local-registry-server"&gt;
&lt;h3&gt;Step 4: Add the image to the local registry server&lt;/h3&gt;
&lt;p&gt;Now we need a way to get the image from the workstation onto the
Raspberry Pi. Of course, I could manually transfer the file with a USB
stick or possibly use ssh, but what if I have multiple Pi's? This
process could become cumbersome. Docker provides a few ways to push
and pull images across a network. The most obvious is &lt;a class="reference external" href="https://hub.docker.com/"&gt;Dockerhub&lt;/a&gt;, a site for freely sharing images. For the
moment I don't want to use Dockerhub, though, because I have not yet
checked all the software licenses and am unsure as to what my rights
are for putting an image with Micro-Manager software on a public
repository.&lt;/p&gt;
&lt;p&gt;A better option, especially for testing, is to use a local registry
server. This server operates only on my home network and already
allows my workstation and Pi's to communicate with one
another. Following the &lt;a class="reference external" href="https://docs.docker.com/registry/deploying/"&gt;official registry documentation&lt;/a&gt; and &lt;a class="reference external" href="http://zacharykeeton.com/docker-private-registry/"&gt;this blog post by
Zachary Keeton&lt;/a&gt;,
I managed to setup the registry as follows.&lt;/p&gt;
&lt;div class="section" id="host-setup"&gt;
&lt;h4&gt;Host setup&lt;/h4&gt;
&lt;p&gt;First, we need to setup a transport layer security (TLS)
certificate. It's possible to run the server without one if you don't
expect your network to be attacked, but it's good practice so let's
create one.&lt;/p&gt;
&lt;p&gt;To do this, I edit the /etc/ssl/openssl.cnf file and add the following
to the top of the [ v3_ca ] section.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
subjectAltName = IP:192.168.XXX.XXX
&lt;/pre&gt;
&lt;p&gt;where the IP address is the address of the workstation on the
network. Next, I actually create the certificate. I make a directory
called certs inside my workstation home directory and then use openssl
to make the cerficate. During the prompts, I press ENTER at every step
except the FQDN (fully qualified domain name). For the FQDN, I enter
the same IP address as above.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f09e02f3f4da44c59e52cff527fbd035-1"&gt;&lt;/a&gt;mkdir certs
&lt;a name="rest_code_f09e02f3f4da44c59e52cff527fbd035-2"&gt;&lt;/a&gt;openssl req -newkey rsa:4096 -nodes -sha256 &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_f09e02f3f4da44c59e52cff527fbd035-3"&gt;&lt;/a&gt;-keyout certs/domain.key -x509 -days &lt;span class="m"&gt;365&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_f09e02f3f4da44c59e52cff527fbd035-4"&gt;&lt;/a&gt;-config /etc/ssl/openssl.cnf -out certs/domain.crt
&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;I had to add the ``-config /etc/ssl/openssl.cnf`` argument for the
subject alternative name to be added to the certificate.&lt;/strong&gt; This part
was tricky, because if this argument is not included, then the key
generation step will use some other .cnf file (I am not sure
which). This results in the following SAN error when attemptingt to
connect to the registry.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cannot validate certificate for 192.168.XXX.XXX because it doesn't contain any IP SANs
&lt;/pre&gt;
&lt;p&gt;After the domain.key and domain.crt files have been created, I run the
official registry server container. (See how handy Docker containers
are? There's no messy installation beyond grabbing the container.)&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-1"&gt;&lt;/a&gt;docker run -d -p &lt;span class="m"&gt;5000&lt;/span&gt;:5000 &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-2"&gt;&lt;/a&gt;  --restart&lt;span class="o"&gt;=&lt;/span&gt;always &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-3"&gt;&lt;/a&gt;  --name registry &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-4"&gt;&lt;/a&gt;  -v &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;/certs:/certs &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-5"&gt;&lt;/a&gt;  -e &lt;span class="nv"&gt;REGISTRY_HTTP_TLS_CERTIFICATE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/certs/domain.crt &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-6"&gt;&lt;/a&gt;  -e &lt;span class="nv"&gt;REGISTRY_HTTP_TLS_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/certs/domain.key &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_3c7d4492bdd544a0ab29f19053fed1b5-7"&gt;&lt;/a&gt;  registry:2
&lt;/pre&gt;&lt;p&gt;If the registry:2 image is not already downloaded, then it will be
downloaded for automatically when running the container. Note that
the -p 5000:5000 argument indicates that the server is using port 5000
on both the host system and inside the container. Note also that the
certs directory is relative to the current directory because I use the
($pwd) command. You can change this to an absolute path if you wish on
your setup.&lt;/p&gt;
&lt;p&gt;Let's go ahead and push the application image to the server now that
it's running.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_8a7ac257787c4eba9122b1a51394579d-1"&gt;&lt;/a&gt;docker push localhost:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="setup-the-pi"&gt;
&lt;h4&gt;Setup the Pi&lt;/h4&gt;
&lt;p&gt;Now, startup the Pi. I will assume that you have &lt;a class="reference external" href="https://www.raspberrypi.org/blog/docker-comes-to-raspberry-pi/"&gt;already installed
Docker&lt;/a&gt; on
it and know how to communicate with it via ssh and copy files to it
using scp.&lt;/p&gt;
&lt;p&gt;I copy the certificate from the host with scp.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_f81dcc28dbf34e3ea1bf9e19a860b92b-1"&gt;&lt;/a&gt;sudo mkdir -p /etc/docker/certs.d/192.168.XXX.XXX:5000/
&lt;a name="rest_code_f81dcc28dbf34e3ea1bf9e19a860b92b-2"&gt;&lt;/a&gt;sudo scp kmdouglass@192.168.XXX.XXX:/home/kmdouglass/certs/domain.crt /etc/docker/certs.d/192.168.XXX.XXX:5000/ca.crt
&lt;/pre&gt;&lt;p&gt;The IP address that I am using is the one to the machine where the
registry server is running. After this step, I make the operating
system trust the certificate.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_1603979d854c4fc09abeab85dfb17b86-1"&gt;&lt;/a&gt;sudo scp kmdouglass@192.168.XXX.XXX:/home/kmdouglass/certs/domain.crt /usr/local/share/ca-certificates/192.168.XXX.XXX.crt
&lt;a name="rest_code_1603979d854c4fc09abeab85dfb17b86-2"&gt;&lt;/a&gt;sudo update-ca-certifications
&lt;/pre&gt;&lt;p&gt;Finally, I restart the Docker daemon.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_a30030b90b9e48cbbc663ed71086bb1f-1"&gt;&lt;/a&gt;sudo service docker restart
&lt;/pre&gt;&lt;p&gt;If everything is working, then I should be able to pull the image from
your network's registry server.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_07188abc472a47509f522f8550ed5a8b-1"&gt;&lt;/a&gt;docker pull &lt;span class="m"&gt;192&lt;/span&gt;.168.XXX.XXX:5000/rpi-micromanager:python2.0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-5-run-micro-manager"&gt;
&lt;h3&gt;Step 5: Run Micro-Manager!&lt;/h3&gt;
&lt;p&gt;And now the moment of truth: running the application container. Since
it's setup to run Python automatically, I use a pretty simple &lt;tt class="docutils literal"&gt;docker
run&lt;/tt&gt; command.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_bd02e1afc3c4450f9b9eb38f759b2c16-1"&gt;&lt;/a&gt;docker run -it --rm &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_bd02e1afc3c4450f9b9eb38f759b2c16-2"&gt;&lt;/a&gt;     --name micro-manager &lt;span class="se"&gt;\&lt;/span&gt;
&lt;a name="rest_code_bd02e1afc3c4450f9b9eb38f759b2c16-3"&gt;&lt;/a&gt;     &lt;span class="m"&gt;192&lt;/span&gt;.168.XXX.XXX:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;&lt;p&gt;I verify that the Micro-Manager Python wrapper is working by trying to
import it and run &lt;a class="reference external" href="https://micro-manager.org/wiki/Using_the_Micro-Manager_python_library"&gt;a few basic commands&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_3f3a9c36707841cd9a854d6c7ffed10f-1"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;MMCorePy&lt;/span&gt;
&lt;a name="rest_code_3f3a9c36707841cd9a854d6c7ffed10f-2"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mmc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MMCorePy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CMMCore&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_3f3a9c36707841cd9a854d6c7ffed10f-3"&gt;&lt;/a&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mmc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getVersionInfo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;If these work without error, then congratulations! You're now ready to
start building your embedded microscopy system ;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-6-running-the-whole-process"&gt;
&lt;h3&gt;Step 6: Running the whole process&lt;/h3&gt;
&lt;p&gt;The beauty of having scripted all these steps is that the full
workflow may be executed quite simply. From the host system's build
folder, run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/build$ ./build
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/build$ ./run /path/to/source true
&lt;/pre&gt;
&lt;p&gt;From the 2.0-python folder:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@xxxxx:~/src/alphapi/docker/rpi-micromanager/2.0-python ./build /path/to/source/artifacts
kmdouglass@xxxxx:~$ docker push localhost:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;
&lt;p&gt;And from the Raspberry Pi:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pi@yyyyy:~$ docker pull 192.168.XXX.XXX:5000/rpi-micromanager:2.0-python
pi@yyyyy:~$ docker run -it --rm \
                   --name micro-manager \
                   192.168.XXX.XXX:5000/rpi-micromanager:2.0-python
&lt;/pre&gt;
&lt;p&gt;Hopefully this is enough to get you started building Micro-Manager for
the Raspberry Pi with Docker. Though I focused on Micro-Manager, the
workflow should be generally applicable to any large scale project in
which you want to isolate the build environment from the host machine.&lt;/p&gt;
&lt;p&gt;If you have any questions, just leave them in the comments. Happy
programming!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>docker</category><category>micro-manager</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/how-i-built-a-cross-compilation-workflow-for-the-raspberry-pi/</guid><pubDate>Sun, 29 Apr 2018 10:10:26 GMT</pubDate></item><item><title>Connecting a Raspberry Pi to a home Linux network</title><link>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;I recently purchased a Raspberry Pi 3 Model B and have been tinkering
with it for a few days. One of the first things I decided to do was to
set it up so that I could access it from my laptop over my home
network. This post contains a step-by-step explanation of the
process. If you have any questions, feel free to leave a comment or
send me an e-mail.&lt;/p&gt;
&lt;div class="section" id="collect-the-necessary-information"&gt;
&lt;h2&gt;Collect the necessary information&lt;/h2&gt;
&lt;p&gt;To start, we need to collect a little bit of information about the
home network. My internet is provided by a local company that supplied
me with a Thomson TWG-870 router. This router determines the IP
addresses of all the devices on my network. Since my laptop is running
Linux (Debian Jessie, to be exact), I can use the &lt;code&gt;netstat&lt;/code&gt;
command to get the IP address of the router.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlan0
&lt;/pre&gt;
&lt;p&gt;The key part of this output is the &lt;code&gt;Gateway&lt;/code&gt; column. A gateway
is the IP address of the device (i.e. the router) that provides
devices on a local network with access to the Internet.&lt;/p&gt;
&lt;p&gt;Knowing the IP address of the gateway, we can next trying entering it
directly into the address bar of a web browser. On my machine, this
opened a dialog asking for a username and password. (If you're not
sure what these are, try asking your ISP. And if you haven't changed
them from the default settings, then you really should do this.) After
entering them and clicking &lt;strong&gt;OK&lt;/strong&gt;, the browser window displayed the
general configuration pages for the router.&lt;/p&gt;
&lt;p&gt;The next few steps will depend on the specific router. The information
we are after is the list of IP addresses that the router reserves for
static IP's. A static IP address is an address that is assigned to a
device and doesn't change. Many routers have a so-called DHCP server
that dynamically assigns IP addresses to devices such as smart phones
as they log onto the network. We probably want to always find the Pi
at the same address, however, so a static IP makes more sense than one
that the router dynamically assigns.&lt;/p&gt;
&lt;p&gt;To find the list of static IP's on my specific router, I clicked on
the link entitled &lt;strong&gt;Network&lt;/strong&gt; in my router's configuration page. The
relevant information for me looks like that in the image below:&lt;/p&gt;
&lt;img alt="DHCP address pool" class="align-center" src="http://kmdouglass.github.io/images/dhcp_addresses.png"&gt;
&lt;p&gt;This information is telling us that the router is reserving addresses
192.168.0.10 to 192.168.0.254 for the DHCP server. We can therefore
most probably use 192.168.0.2 through 9 for static IP's. (Remember
that 192.168.0.1 is already taken; it's the address of the router.) I
tested 192.168.0.2 by pinging it and received no response, so we will
use this address for my Raspberry Pi. (Use Ctrl-C to stop pinging the
device.):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ ping 192.168.0.2
PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.
From 192.168.0.15 icmp_seq=1 Destination Host Unreachable
From 192.168.0.15 icmp_seq=2 Destination Host Unreachable
From 192.168.0.15 icmp_seq=3 Destination Host Unreachable
^C
--- 192.168.0.2 ping statistics ---
4 packets transmitted, 0 received, +3 errors, 100% packet loss, time 3014ms
pipe 3
&lt;/pre&gt;
&lt;p&gt;For the next step, we need to collect the broadcast and subnet mask of
the network. We can do this from the laptop that is already connected
to the network by running the &lt;code&gt;sudo ifconfig&lt;/code&gt; command. This
command will report information that looks similar to the following
example (note that this is not from my machine but is merely for
illustration)::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
eth0 Link encap:Ethernet HWaddr 00:10:5A:1A:DC:65
inet addr:198.209.253.169 Bcast:208.141.109.255 Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:18940 errors:1 dropped:0 overruns:0 frame:2
TX packets:11554 errors:0 dropped:0 overruns:0 carrier:0
collisions:2 txqueuelen:100
RX bytes:4087250 (3.8 Mb) TX bytes:2499423 (2.3 Mb)
Interrupt:11 Base address:0xd000
&lt;/pre&gt;
&lt;p&gt;The very first line tells us that this block of output belongs to the
&lt;strong&gt;eth0&lt;/strong&gt; interface. If you connect to the internet on your laptop
through WiFi, then you may need to find the information for the
&lt;strong&gt;wlan0&lt;/strong&gt; interface instead. wlan0 is usually used to refer to
wireless interfaces in Ubuntu and Debian Linux.&lt;/p&gt;
&lt;p&gt;The first line of output from ifconfig also provides the type of
hardware and the ID of the ethernet card. The information we need,
however, is on the second line. The device's IP address on the network
is &lt;strong&gt;inet addr:198.209.253.169&lt;/strong&gt;, but we don't really need this
information. Rather, we need the two numbers that come next. The
broadcast IP is reported in &lt;strong&gt;Bcast:208.141.109.255&lt;/strong&gt; and the subnet
mask in &lt;strong&gt;Mask:255.255.255.0&lt;/strong&gt;. The &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Broadcast_address"&gt;broadcast IP&lt;/a&gt; is used to send
messages to all devices on the network, whereas the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Subnetwork"&gt;subnet mask&lt;/a&gt; is
used to separate the parts of an address that identify the network
from the parts that identify the devices and possible "sub-networks."&lt;/p&gt;
&lt;p&gt;To summarize this section, we need:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The static IP address that we'll assign to the Pi&lt;/li&gt;
&lt;li&gt;The IP address of the router, i.e. the gateway address&lt;/li&gt;
&lt;li&gt;The broadcast IP&lt;/li&gt;
&lt;li&gt;The subnet mask&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-pi"&gt;
&lt;h2&gt;Configure the Pi&lt;/h2&gt;
&lt;p&gt;Now that we have decided on an IP address for the Pi, let's boot it up
and configure it to always use this IP address. (I am currently using
the &lt;strong&gt;NOOBS&lt;/strong&gt; operating system that came with my Pi starter kit, but
this should work with other flavors of Debian Linux as well.)&lt;/p&gt;
&lt;p&gt;Once logged on to the Pi, open a terminal and make a backup copy of
the file &lt;strong&gt;/etc/network/interfaces&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo cp /etc/network/interfaces /etc/network/interfaces.bak
&lt;/pre&gt;
&lt;p&gt;Making a backup is good practice; in case we ruin the configuration
file, we can simply rewrite it using our backup. Next, open the
original &lt;strong&gt;interfaces&lt;/strong&gt; file for editing. In this example, I'll use
the &lt;strong&gt;nano&lt;/strong&gt; editor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo nano /etc/network/interfaces
&lt;/pre&gt;
&lt;p&gt;In this file, add the following lines (replacing the addresses with
those appropriate for your network):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
auto eth0
iface eth0 inet static
    address 192.168.0.2
    netmask 255.255.255.0
    gateway 192.168.0.1
    broadcast 192.168.0.255
&lt;/pre&gt;
&lt;p&gt;What do these lines do, you ask? Let's step through them one-by-one.&lt;/p&gt;
&lt;div class="section" id="start-the-network-interface-at-boot"&gt;
&lt;h3&gt;Start the network interface at boot&lt;/h3&gt;
&lt;p&gt;First off, we need to identify the network interface. &lt;strong&gt;eth0&lt;/strong&gt; is the
identifier that is referring to the dedicated ethernet port on the
Pi. The line &lt;strong&gt;auto eth0&lt;/strong&gt; means that this interface will be started
at boot.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-interface-to-use-a-static-ip"&gt;
&lt;h3&gt;Configure the interface to use a static IP&lt;/h3&gt;
&lt;p&gt;Next, we see the line &lt;strong&gt;iface eth0 inet static&lt;/strong&gt;. First, &lt;strong&gt;iface
eth0&lt;/strong&gt; means that we are configuring the ethernet port interface that
was described in the last section. Following that, &lt;strong&gt;inet&lt;/strong&gt; specifies
that the interface uses TCP/IP networking. Finally, &lt;strong&gt;static&lt;/strong&gt; is
telling the NOOBS operating system that the device is going to request
a static IP address from the router. (I obtained this explanation from
&lt;a class="reference external" href="http://askubuntu.com/questions/411616/what-does-keywords-in-my-etc-network-interfaces-means"&gt;this forum post&lt;/a&gt;.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="set-the-various-addresses"&gt;
&lt;h3&gt;Set the various addresses&lt;/h3&gt;
&lt;p&gt;The next lines are indented because they are properties of the &lt;strong&gt;inet
static&lt;/strong&gt; family. If you've read everything until now, you should be
able to figure out what addresses to enter next for each option. The
desired static IP address for the Pi should follow the &lt;strong&gt;address&lt;/strong&gt;
field; the subnet mask, gateway, and broadcast IP's described above
should follow &lt;strong&gt;netmask&lt;/strong&gt;, &lt;strong&gt;gateway&lt;/strong&gt;, and &lt;strong&gt;broadcast&lt;/strong&gt;
respectively.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;network&lt;/strong&gt; property (which is not shown above) contains the
network address and &lt;a class="reference external" href="http://man.cx/interfaces%285%29"&gt;is required for 2.0.x kernels&lt;/a&gt;. These kernels
are pretty old by now, so it is unlikely that you will need to specify
this property.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="restart-the-network-interface"&gt;
&lt;h3&gt;Restart the network interface&lt;/h3&gt;
&lt;p&gt;Restarting the interface we just configured on our Pi is as simple
as entering these terminal commands:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ifdown eth0
sudo ifup eth0
&lt;/pre&gt;
&lt;p&gt;(Remember to replace eth0 with the appropriate interface if yours is
different.) If everything goes well, we should be able to use our web
browser to navigate on the Internet. We should also be able to ping
the Pi from the laptop and vice versa.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="connecting-to-the-pi"&gt;
&lt;h2&gt;Connecting to the Pi&lt;/h2&gt;
&lt;p&gt;Once the Pi is on the network, we need a way to connect to it from the
laptop and other devices so that we can actually use it for
something. One way is to use &lt;a class="reference external" href="https://support.suso.com/supki/SSH_Tutorial_for_Linux"&gt;ssh&lt;/a&gt;, or Secure SHell. ssh is program
that let's us securely log on to other devices through a shell
(i.e. terminal). This is useful for when we need to work only on the
command line.&lt;/p&gt;
&lt;p&gt;If, on the other hand, we want a "Remote Desktop"-like GUI
environment, we can use &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;VNC&lt;/a&gt;. The documentation for VNC is quite
good but detailed; I'll let you read up on it on your own if you're
interested in using it.&lt;/p&gt;
&lt;p&gt;I'll now briefly explain how we can set up ssh on the Pi.&lt;/p&gt;
&lt;div class="section" id="edit-vnc-installation"&gt;
&lt;h3&gt;EDIT: VNC installation&lt;/h3&gt;
&lt;p&gt;As it turns out, you may run into some problems if you do try to setup
VNC by following the documentation in the link above. Namely, the
documentation is missing a key step, at least for me. I had to first
install the VNC server software on the Pi via:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get update
sudo apt-get install realvnc-vnc-server
&lt;/pre&gt;
&lt;p&gt;Even though the rest of this post is about ssh, you may still find
this information useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enable-ssh-on-the-pi"&gt;
&lt;h3&gt;Enable ssh on the Pi&lt;/h3&gt;
&lt;p&gt;We need to enable ssh access to the Pi before we can use it. On the
Pi, open a terminal and run the configuration utility::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo raspi-config
&lt;/pre&gt;
&lt;p&gt;We should see the following window appear.&lt;/p&gt;
&lt;img alt="The raspi-config menu with Interface Options highlighted." class="align-center" src="http://kmdouglass.github.io/images/pi-config-interface-options.png"&gt;
&lt;p&gt;Use the keyboard to highlight &lt;strong&gt;Interface Options&lt;/strong&gt; and tap the Enter
key. In the following menu, we now should see an option to enable ssh
as in the following image. Use the keyboard to highlight &lt;strong&gt;P2 SSH&lt;/strong&gt;
(or the relevant menu item if the name is different on your Pi) and
hit the Enter key to enable it. Once ssh is enabled, we can hit Esc or
select the &amp;lt;Back&amp;gt; option to until we exit the configuration utility.&lt;/p&gt;
&lt;img alt="The raspi-config Interface Options menu with P2 SSH highlighted." class="align-center" src="http://kmdouglass.github.io/images/pi-config-ssh.png"&gt;
&lt;p&gt;If you'e following along, you may need to restart your Pi for these
changes to take effect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="log-onto-the-pi-from-the-laptop"&gt;
&lt;h3&gt;Log onto the Pi from the laptop&lt;/h3&gt;
&lt;p&gt;Now for the moment of truth. After restarting the Pi, &lt;strong&gt;we need to
first ensure that we are not logged in to it&lt;/strong&gt;. If we are, simply
click the &lt;strong&gt;Menu&lt;/strong&gt; button, followed by &lt;strong&gt;Shutdown... -&amp;gt; Logout&lt;/strong&gt; and
log out of the session.&lt;/p&gt;
&lt;p&gt;Next, open a terminal on the laptop and enter the following command,
changing the IP address to whatever was decided upon for the Pi::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssh pi@192.168.0.2
&lt;/pre&gt;
&lt;p&gt;This command runs the ssh program and asks to sign into the Pi as the
user called &lt;strong&gt;pi&lt;/strong&gt;. After running the command, we may be prompted for
a password to log on if one was set on the Pi. (You did set one,
didn't you?) Once successfully entering the password, we should notice
that the terminal prompt has changed to something like
&lt;code&gt;pi@raspberrypi:~ $&lt;/code&gt;. This indicates that we are logged on to
the Pi. If we enter the &lt;code&gt;ls&lt;/code&gt; command, we should see the contents
of the Pi's home directory. When we're ready to disconnect from the
Pi, we can simply use the &lt;code&gt;exit&lt;/code&gt; command at any time in the
terminal. The prompt should change to reflect that we are back on our
laptop machine when we have successfully exited.&lt;/p&gt;
&lt;p&gt;If this is all working as described above, then congratulations on
connecting your Pi to your home Linux network! I wish you many happy
hours of hacking :)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="further-reading"&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The Debian network setup manual is very detailed and describes
many, many more aspects of setting up a network than I touched upon
here. &lt;a class="reference external" href="https://www.debian.org/doc/manuals/debian-reference/ch05.en.html"&gt;https://www.debian.org/doc/manuals/debian-reference/ch05.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Raspberry Pi documentation about VNC (Virtual Network
Computing) is a great resource for setting up a graphical interface
to remotely connect to your
Pi. &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;https://www.raspberrypi.org/documentation/remote-access/vnc/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>linux</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network/</guid><pubDate>Sun, 05 Feb 2017 09:28:17 GMT</pubDate></item></channel></rss>