<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (Posts about rust)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link href="http://kmdouglass.github.io/categories/rust.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 26 Feb 2019 06:00:06 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A simple UNIX socket listener in Rust</title><link>http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;I decided that I wanted to learn a new programming language in 2019. After a bit of research, I
settled upon &lt;a class="reference external" href="https://www.rust-lang.org/"&gt;Rust&lt;/a&gt; due to its speed, novel ideas about memory safety, and &lt;a class="reference external" href="https://blog.rust-lang.org/2018/03/12/roadmap.html#four-target-domains"&gt;focus on two areas
that I am interested in&lt;/a&gt;: embedded systems and WebAssembly. While I think that &lt;a class="reference external" href="https://doc.rust-lang.org/book/"&gt;The Book&lt;/a&gt; is the
best place to get started learning the language, nothing is a really a substitute for writing
code.&lt;/p&gt;
&lt;p&gt;With that in mind, I developed an idea for a starting project: a background daemon for Linux
systems like the Raspberry Pi that controls and reads data from the system's peripherals. The
design of this project is inspired by Docker: a daemon process does most of the heavy work while a
command line tool communicates with the Daemon over a Unix socket (typically a file located at
&lt;tt class="docutils literal"&gt;/var/run/docker.sock&lt;/tt&gt;). The purpose of this post is to demonstrate the most basic realization of
this: reading text from a UNIX socket in Rust. And to emphasize that the UNIX socket is used for
communication between two separate processes, we will send messages from Bash to Rust.&lt;/p&gt;
&lt;p&gt;Keep in mind that this is my first-ever Rust program, so it may not be completely idiomatic
Rust. The follow was compiled with rustc 1.32.0 (9fda7c223 2019-01-16).&lt;/p&gt;
&lt;p&gt;To begin, I created a new Rust project with &lt;tt class="docutils literal"&gt;cargo&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_cf489af8c90143cfa29db798c98cc3f8-1"&gt;&lt;/a&gt;$ cargo new rust-uds
&lt;a name="rest_code_cf489af8c90143cfa29db798c98cc3f8-2"&gt;&lt;/a&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; rust-uds
&lt;/pre&gt;&lt;p&gt;Next, I opened the file that cargo automatically generated in &lt;tt class="docutils literal"&gt;src/main.rs&lt;/tt&gt;, removed the
auto-generated content, and added the following code, which is largely based on the &lt;a class="reference external" href="https://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#examples"&gt;example&lt;/a&gt;
provided in the Rust documentation but with a few key differences:&lt;/p&gt;
&lt;table class="codetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-1"&gt; 1&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-2"&gt; 2&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-3"&gt; 3&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-4"&gt; 4&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-5"&gt; 5&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-6"&gt; 6&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-7"&gt; 7&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-8"&gt; 8&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-9"&gt; 9&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-10"&gt;10&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-11"&gt;11&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-12"&gt;12&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-13"&gt;13&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-14"&gt;14&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-15"&gt;15&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-16"&gt;16&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-17"&gt;17&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-18"&gt;18&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-19"&gt;19&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-20"&gt;20&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-21"&gt;21&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-22"&gt;22&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-23"&gt;23&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-24"&gt;24&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-25"&gt;25&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_57f78f465e87409d9622b3743cad53de-26"&gt;26&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre class="code rust"&gt;&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;io&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-2"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;os&lt;/span&gt;::&lt;span class="n"&gt;unix&lt;/span&gt;::&lt;span class="n"&gt;net&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-4"&gt;&lt;/a&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-5"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;: &lt;span class="nc"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-6"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-7"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-8"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-9"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-10"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-12"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-13"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;::&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/tmp/rust-uds.sock"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-15"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incoming&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-16"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-17"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-18"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;::&lt;span class="n"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-19"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-20"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-21"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Error: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-22"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-23"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-24"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-25"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_57f78f465e87409d9622b3743cad53de-26"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div class="section" id="explanation"&gt;
&lt;h2&gt;Explanation&lt;/h2&gt;
&lt;p&gt;The first three lines import the necessary modules for this code example.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_b6a0acba0e394b1ab2f35106acf540fe-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;io&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_b6a0acba0e394b1ab2f35106acf540fe-2"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;os&lt;/span&gt;::&lt;span class="n"&gt;unix&lt;/span&gt;::&lt;span class="n"&gt;net&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_b6a0acba0e394b1ab2f35106acf540fe-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;&lt;tt class="docutils literal"&gt;BufRead&lt;/tt&gt; is a trait that enables extra ways of reading data sources; in this case, it has an
internal buffer for reading the socket line-by-line. &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt; is a struct that actually
implements the functionality in &lt;tt class="docutils literal"&gt;BufRead&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;UnixStream&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;UnixListener&lt;/tt&gt; are structs that
provide the functionality for handling the UNIX socket, and the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::thread&lt;/span&gt;&lt;/tt&gt; module is used to
spawn threads.&lt;/p&gt;
&lt;p&gt;The next set of lines defines a function named &lt;tt class="docutils literal"&gt;handle_client()&lt;/tt&gt; that is called whenever new data
arrives in the stream. The explanation for this is best left until after the &lt;tt class="docutils literal"&gt;main()&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;The first line in the &lt;tt class="docutils literal"&gt;main()&lt;/tt&gt; function creates the UnixListener struct and binds it to the
&lt;tt class="docutils literal"&gt;listener&lt;/tt&gt; variable.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_7d8f3d39e1da4338b07cbb8b8937cee6-1"&gt;&lt;/a&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;::&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/tmp/rust-uds.sock"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The &lt;tt class="docutils literal"&gt;bind()&lt;/tt&gt; function takes a string argument that is a path to the socket file and &lt;tt class="docutils literal"&gt;unwrap()&lt;/tt&gt;
moves the value out of the Result that is returned by &lt;tt class="docutils literal"&gt;bind()&lt;/tt&gt;. (This is a pattern that is
&lt;a class="reference external" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"&gt;discouraged&lt;/a&gt; in Rust but is OK for quick prototypes because it simplifies the error handling.)&lt;/p&gt;
&lt;p&gt;After creating the listener, &lt;tt class="docutils literal"&gt;listener.incoming()&lt;/tt&gt; returns an iterator over the incoming
connections to the socket. The connections are looped over in an infinite for loop; I believe that
this is more-or-less the same as a generator in Python which never raises a &lt;tt class="docutils literal"&gt;StopIteration&lt;/tt&gt;
exception.&lt;/p&gt;
&lt;p&gt;Next, the &lt;tt class="docutils literal"&gt;Result&lt;/tt&gt; of the incoming streams is matched; if there is an error, it is printed and
the loop it exited:&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_9007ff3cc2f94d84910c0a1aa35f346f-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_9007ff3cc2f94d84910c0a1aa35f346f-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Error: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_9007ff3cc2f94d84910c0a1aa35f346f-3"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_9007ff3cc2f94d84910c0a1aa35f346f-4"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;However, if the &lt;tt class="docutils literal"&gt;Result&lt;/tt&gt; of the connection is &lt;tt class="docutils literal"&gt;Ok&lt;/tt&gt;, then a new thread is spawned to handle the
new stream:&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_9364da6430984347967a7efe86f42dad-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_9364da6430984347967a7efe86f42dad-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;::&lt;span class="n"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_9364da6430984347967a7efe86f42dad-3"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Finally, the client handler is called for each connection.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;: &lt;span class="nc"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-3"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-4"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-5"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_445a6bbae86d44b8908c06528d359809-6"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The handler in this case is fairly straight-forward. It shadows the original &lt;tt class="docutils literal"&gt;stream&lt;/tt&gt; variable by
binding it to a version of itself that has been converted to a &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;. Finally, it loops
over the &lt;tt class="docutils literal"&gt;lines()&lt;/tt&gt; iterator, which blocks until a new line appears in the stream.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sending-messages"&gt;
&lt;h2&gt;Sending messages&lt;/h2&gt;
&lt;p&gt;As an example, let's send messages to the Rust program via Bash using &lt;a class="reference external" href="http://man.openbsd.org/nc"&gt;the OpenBSD version of
netcat&lt;/a&gt;. (The OpenBSD version seems to be the default on Ubuntu-based systems.) This should
underscore the fact that the UNIX socket is really being used to communicate between two different
processes.&lt;/p&gt;
&lt;p&gt;First, compile and run the Rust program to start the socket listener:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_783e25274cee4b90bf839bafb17db3b7-1"&gt;&lt;/a&gt;$ cargo run --release
&lt;a name="rest_code_783e25274cee4b90bf839bafb17db3b7-2"&gt;&lt;/a&gt;   Compiling rust-uds v0.1.0 (/home/kmd/src/rust-uds)
&lt;a name="rest_code_783e25274cee4b90bf839bafb17db3b7-3"&gt;&lt;/a&gt;    Finished release [optimized] target(s) in 1.59s
&lt;a name="rest_code_783e25274cee4b90bf839bafb17db3b7-4"&gt;&lt;/a&gt;     Running `target/release/rust-uds`
&lt;/pre&gt;&lt;p&gt;Open up a new terminal. You should see the socket file /tmp/rust-uds.sock:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_4cc0fbc5fddd47e7a44fdee2c6914b27-1"&gt;&lt;/a&gt;$ ls /tmp | grep rust
&lt;a name="rest_code_4cc0fbc5fddd47e7a44fdee2c6914b27-2"&gt;&lt;/a&gt;rust-uds.sock
&lt;/pre&gt;&lt;p&gt;Now let's send messages to the rust program. Use the following netcat command to open a connection
to the socket.&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_bf8168653546403caefb21172f43b73f-1"&gt;&lt;/a&gt;$ nc -U /tmp/rust-uds.sock
&lt;/pre&gt;&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-U&lt;/span&gt;&lt;/tt&gt; is necessary to indicate to netcat that this is a UNIX stream socket. Now, start typing
text into the same window. Every time you press ENTER, you should see the same text appear in the
terminal window in which the Rust program is running. Press CTRL-C to exit the Rust socket
listener. If you re-run the program, delete the old socket first: &lt;tt class="docutils literal"&gt;rm &lt;span class="pre"&gt;/tmp/rust-uds.sock&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use a &lt;tt class="docutils literal"&gt;UnixListener&lt;/tt&gt; struct to create a UNIX socket and listen to it for connections.&lt;/li&gt;
&lt;li&gt;For each new connection, spawn a new thread and read the stream with a &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Print each new line in the stream by iterating over the &lt;tt class="docutils literal"&gt;lines()&lt;/tt&gt; iterator of the
&lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Send commands to your Rust program from bash with &lt;tt class="docutils literal"&gt;nc &lt;span class="pre"&gt;-U&lt;/span&gt; "$PATH_TO_SOCKET"&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>linux</category><category>rust</category><guid>http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/</guid><pubDate>Sun, 24 Feb 2019 15:25:58 GMT</pubDate></item></channel></rss>