<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (raspberry pi)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link rel="self" href="http://kmdouglass.github.io/categories/raspberry-pi.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sat, 26 Aug 2017 21:35:00 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Accessing the Raspberry Pi camera image sensor</title><link>http://kmdouglass.github.io/posts/accessing-the-raspberry-pi-camera-image-sensor.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; You can easily ruin your Raspberry Pi camera module by
following the steps in this post. Proceed with caution.&lt;/p&gt;
&lt;p&gt;Over the past half year I have been making slow but steady progress on
&lt;a class="reference external" href="https://hackaday.io/project/19677-basic-lensless-imaging-for-low-cost-microscopy"&gt;my lensless imager project&lt;/a&gt;. The
purpose, aside from having a bit of fun, is to create an imaging
system for basic cell biology that doesn't use an expensive microscope
objective.&lt;/p&gt;
&lt;p&gt;A lensless imager works just as its name implies: an image sensor
records the scattered light from a microscopic, transparent object and
computationally reconstructs an image of that object, all without a
lens. The best resolutions are achieved when the object is relatively
close to the image sensor. Ideally, the separation between the object
and the sensor's pixels would be at most about one millimeter. &lt;a class="reference external" href="http://innovate.ee.ucla.edu/wp-content/uploads/2016/01/annurev-bioeng-092515-010849.pdf"&gt;This
limit is partly determined by the light source's spatial coherence&lt;/a&gt;,
but also by the fact that high resolution is achieved by recording the
scattered light at very large angles, which is possible only when the
sample is close to the sensor.&lt;/p&gt;
&lt;p&gt;Today I had a bit of free time so I decided to see whether I could
remove the housing that surrounds the Raspberry Pi camera's
sensor. The &lt;a class="reference external" href="https://www.raspberrypi.org/products/camera-module-v2/"&gt;Raspberry Pi Camera Module version 2&lt;/a&gt; sensor is a
Sony IMX219 color chip. Directly above the sensor is a filter, a lens,
and the housing for both of these that prevent me from placing
anything closer than about half a centimeter from the sensor plane. If
I would want to use this camera for the lensless imager, then the
housing would have to go.&lt;/p&gt;
&lt;p&gt;Now, even without the housing the Raspberry Pi camera is not
necessarily the best option for the project because the IMX219 is a
color sensor. This means that there is a Bayer filter over its pixels,
which would cut the resolution of the imager since I would be using a
very narrow band light source. Effectively, only a quarter of the
pixels would be receiving any light. Regardless, I had a spare second
camera and it interfaces well with the Raspberry Pi, so I figured it
would make for a good prototype.&lt;/p&gt;
&lt;p&gt;As you will see, I did slightly damage my sensor, though it seems to
still work. &lt;strong&gt;You can easily ruin your camera module or cut your
finger by following these steps, so proceed at your own risk.&lt;/strong&gt;&lt;/p&gt;
&lt;div class="section" id="step-0-the-raspberry-pi-camera-module-v2"&gt;
&lt;h2&gt;Step 0: The Raspberry Pi Camera Module V2&lt;/h2&gt;
&lt;p&gt;In the picture below you see my Raspberry Pi Camera Module. From
above, you can see the small circular aperture with the lens
immediately behind it. The sensor is inside the small gray rectangular
housing that is attached to the control board by a small ribbon cable
(to its right) and a bit of two-sided sticky foam tape (underneath the
sensor; not visible).&lt;/p&gt;
&lt;img alt="The Raspberry Pi Camera Module V2" class="align-center" src="http://kmdouglass.github.io/pi_camera_step0.jpg" style="width: 400px;"&gt;
&lt;/div&gt;
&lt;div class="section" id="step-1-remove-the-main-ribbon-cable"&gt;
&lt;h2&gt;Step 1: Remove the main ribbon cable&lt;/h2&gt;
&lt;p&gt;To make working on the board a bit easier, I removed the white ribbon
cable that attaches the module to the Pi. I did this by pulling on the
black tabs on the two ends of the connecter until the cable is easily
removed. I labeled the sides of the ribbon cable just in case.&lt;/p&gt;
&lt;img alt="Remove the main ribbon cable from the control board" class="align-center" src="http://kmdouglass.github.io/pi_camera_step1.jpg" style="width: 400px;"&gt;
&lt;/div&gt;
&lt;div class="section" id="step-2-detach-the-sensor-s-ribbon-cable"&gt;
&lt;h2&gt;Step 2: Detach the sensor's ribbon cable&lt;/h2&gt;
&lt;p&gt;Next, I used my finger and thumb nail to remove the small ribbon cable
that attaches the sensor to the control board. I essentially applied a
small torque to the bottom edge of the connector until it just
"popped" up, as seen in the second image below.&lt;/p&gt;
&lt;img alt="The small ribbon cable from the sensor is to the right." class="align-center" src="http://kmdouglass.github.io/pi_camera_step2.jpg" style="width: 400px;"&gt;
&lt;/div&gt;
&lt;div class="section" id="step-3-remove-the-sensor-from-the-control-board"&gt;
&lt;h2&gt;Step 3: Remove the sensor from the control board&lt;/h2&gt;
&lt;p&gt;In the third step, I used my thumbnail to gently pry the sensor from
the control board. The sensor is attached with some two-sided sticky
tape and may need a few minutes of work to come free.&lt;/p&gt;
&lt;img alt="Pull the sensor off the control board." class="align-center" src="http://kmdouglass.github.io/pi_camera_step3.jpg" style="width: 400px;"&gt;
&lt;/div&gt;
&lt;div class="section" id="step-4-remove-the-rectangular-housing"&gt;
&lt;h2&gt;Step 4: Remove the rectangular housing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;In this step you risk cutting your finger, so please be careful.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The housing around the sensor is glued. To remove it, you will need to
gently work a knife (or, better yet, a thin screw driver) between the
housing and the sensor board, taking care not to let the blade go too
far into the housing and possibly ruining one of the resistors or wire
bonds.&lt;/p&gt;
&lt;img alt="Cut carefully on one side of the housing." class="align-center" src="http://kmdouglass.github.io/pi_camera_step4.jpg" style="width: 400px;"&gt;
&lt;p&gt;Once you get a knife between the two, try popping the housing off of
the sensor.&lt;/p&gt;
&lt;img alt="Once the edge is cut, pop the housing off." class="align-center" src="http://kmdouglass.github.io/pi_camera_step4b.jpg" style="width: 400px;"&gt;
&lt;p&gt;When I did this I cut on three sides of the housing, but in retrospect
I should have only cut on the side opposite the ribbon cable and pried
the other sides loose. This is because I damaged a small resistor when
the knife blade went too far into the housing. You can see this below
and, at the same time, get an idea of the layout of the sensor board
so you know where you can and can't cut.&lt;/p&gt;
&lt;img alt="The resistor near the top of the board was damaged when cutting the housing." class="align-center" src="http://kmdouglass.github.io/pi_camera_step4c.png" style="width: 400px;"&gt;
&lt;p&gt;If you have the normal version of the camera, then you can also find the IR blocking filter
inside the housing.&lt;/p&gt;
&lt;img alt="The IR blocking filter." class="align-center" src="http://kmdouglass.github.io/pi_camera_step4d.jpg" style="width: 400px;"&gt;
&lt;p&gt;Fortunately for me the camera still works, despite the damaged
resistor. I can now place samples directly on the sensor if I wanted
to, though the wire bonds from the sensor to its control board appear
quite fragile. For this reason, it may make more sense to build a
slide holder that holds a sample just above the surface without
touching it. For now, I can use this exposed sensor to prototype
different methods for mounting the sample.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>optics</category><category>photonics</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/accessing-the-raspberry-pi-camera-image-sensor.html</guid><pubDate>Sat, 26 Aug 2017 21:33:07 GMT</pubDate></item><item><title>Micro-Manager on the Raspberry Pi</title><link>http://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="https://micro-manager.org/"&gt;Micro-Manager&lt;/a&gt; is an open source platform for controlling microscope
hardware, automating image acquisition, and tracking metadata about
how images are acquired. In biomedical imaging research, it serves as
an incredibly important tool because it is free and open source, which
means that scientists can benefit from the contributions of others to
the software without paying costly licensing fees.&lt;/p&gt;
&lt;p&gt;I recently managed to compile Micro-Manager version 2.0 on the
Raspberry Pi. I did this for a small hobby project I am working on to
build a cheap yet effective tool for &lt;a class="reference external" href="https://hackaday.io/project/19677-basic-lensless-imaging-for-low-cost-microscopy"&gt;at-home microscope projects and
hacking&lt;/a&gt;. Though I am not yet convinced that Micro-Manager will be
the best tool for this particular job given it's relatively heavy
footprint on the Pi's slower hardware, I thought that I would post my
notes so that others could benefit from my experience.&lt;/p&gt;
&lt;div class="section" id="software-versions"&gt;
&lt;h2&gt;Software versions&lt;/h2&gt;
&lt;p&gt;I am working with a Raspberry Pi 3 Model B:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pi@raspberrypi:~ $ uname -a &amp;amp; gcc -dumpversion &amp;amp; make -v &amp;amp; ldd --version
Linux raspberrypi 4.4.38-v7+ #938 SMP Thu Dec 15 15:22:21 GMT 2016 armv7l GNU/Linux

pi@raspberrypi:~ $ gcc -dumpversion
4.9.2

pi@raspberrypi:~ $ make -v
GNU Make 4.0

pi@raspberrypi:~ $ ldd --version
ldd (Debian GLIBC 2.19-18+deb8u7) 2.19
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-a-network-share-for-3rd-party-libraries"&gt;
&lt;h2&gt;Setup a network share for 3rd party libraries&lt;/h2&gt;
&lt;p&gt;We need to compile Micro-Manager because binares for the Pi's ARM
processor are not distributed by the Micro-Manager team (probably
because too few people have ever wanted them). To compile
Micro-Manager, we need to checkout a rather large set of 3rd party
libraries. When I last checked, these libraries occupied 6.7 GB of
space on my laptop, a size which can be prohibitive when using the
Micro-SD cards that provide storage for the Pi.&lt;/p&gt;
&lt;p&gt;To circumvent this problem, I checked out the &lt;strong&gt;3rdpartypublic&lt;/strong&gt; SVN
repository onto my laptop and created a network share from this
directory. Then, I mounted the share on my Pi in the directory just
above that containing the Micro-Manager source code.&lt;/p&gt;
&lt;p&gt;To get started, first have a look at my post on connecting a Pi to a
Linux home network for ideas if you haven't already connected the Pi
to your other machines at home:
&lt;a class="reference external" href="http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html"&gt;http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once the Pi and the laptop are on the same network, checkout the SVN
3rdpartypublic repository onto your laptop or home server. You may
need to do this a few times until completion because the downloads can
timeout after a few minutes:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
svn checkout https://valelab4.ucsf.edu/svn/3rdpartypublic/
&lt;/pre&gt;
&lt;p&gt;Next, we need to setup the network share. If your laptop or server is
running Windows, then you will probably need to setup &lt;a class="reference external" href="https://www.samba.org/samba/what_is_samba.html"&gt;Samba&lt;/a&gt; on the
Pi to share files between them. I however am running a Linux home
network, so I decided to use &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Network_File_System"&gt;NFS&lt;/a&gt; (Network File Sharing) to share
the directory between my laptop--which runs Debian Linux--and the
Pi. I installed NFS on my laptop with:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install nfs-kernel-server nfs-common
&lt;/pre&gt;
&lt;p&gt;Once installed, I added the following line to the newly created
/etc/exports file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/home/kmdouglass/src/micro-manager/3rdpartypublic 192.168.0.2/24(ro)
&lt;/pre&gt;
&lt;p&gt;The first part is the directory to share, i.e. where the
3rdpartypublic directory is stored on my laptop. The second part
contains the static IP address of the Pi on my home network. The /24
was REQUIRED for my client (the Pi) to mount the share. /24 simply
denotes a network mask of 255.255.255.0; if you have a different mask
on your network, then you can find a good discussion on this topic
here: &lt;a class="reference external" href="https://arstechnica.com/civis/viewtopic.php?t=751834"&gt;https://arstechnica.com/civis/viewtopic.php?t=751834&lt;/a&gt; Finally,
(...)  specifies shared options and &lt;strong&gt;ro&lt;/strong&gt; means read only.&lt;/p&gt;
&lt;p&gt;After editing the file, export the folder and restart the NFS server:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo exportfs -arv
sudo /etc/init.d/nfs-kernel-server restart
&lt;/pre&gt;
&lt;p&gt;On the client (the Pi), the NFS client software was already
installed. However, I had to restart the rpcbind service before I
could mount the share:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo /etc/init.d/rpcbind restart
&lt;/pre&gt;
&lt;p&gt;Finally, I added a line to the &lt;strong&gt;/etc/fstab&lt;/strong&gt; file on the Pi to make
mounting the 3rdpartypublic share easier:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
192.168.0.102:/home/kmdouglass/src/micro-manager/3rdpartypublic /home/pi/src/micro-manager/3rdpartypublic nfs user,noauto 0 0
&lt;/pre&gt;
&lt;p&gt;The first part indicates the IP of the laptop and the share to
mount. The second part, &lt;strong&gt;/home/pi/src/micro-manager/3rdpartypublic&lt;/strong&gt;
is the directory on the Pi where the share will be mounted. I placed
this one directory above where the MM source code is,
(&lt;strong&gt;/home/pi/src/micro-manager/micro-manager&lt;/strong&gt; on my machine). &lt;strong&gt;nfs&lt;/strong&gt;
indicates the type of share to mount, and &lt;strong&gt;user,noauto&lt;/strong&gt; permits any
user to mount the share (not just root), though this share will not be
automatically mounted when the Pi starts. The final two zeros are
explained in the fstab comments but aren't really important for us. To
mount the share, type the following on the Pi:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo mount /home/pi/src/micro-manager/3rdpartypublic
&lt;/pre&gt;
&lt;p&gt;In case you're interested in learning more about the intricacies of
Linux home networking, I found the following sources of information to
be incredibly helpful.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.howtoforge.com/install_nfs_server_and_client_on_debian_wheezy"&gt;https://www.howtoforge.com/install_nfs_server_and_client_on_debian_wheezy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=luqq8DUqqCw"&gt;https://www.youtube.com/watch?v=luqq8DUqqCw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://nfs.sourceforge.net/nfs-howto/ar01s03.html#config_server_setup"&gt;http://nfs.sourceforge.net/nfs-howto/ar01s03.html#config_server_setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tecmint.com/how-to-setup-nfs-server-in-linux/"&gt;http://www.tecmint.com/how-to-setup-nfs-server-in-linux/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="building-mm"&gt;
&lt;h2&gt;Building MM&lt;/h2&gt;
&lt;p&gt;Once I was able to mount the share containing 3rd party libraries, I
installed the following packages on the Pi and checked out the
Micro-Manager source code:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install autoconf automake libtool pkg-config swig ant libboost-dev libboost-all-dev
cd ~/src/micro-manager
git clone https://github.com/micro-manager/micro-manager.git
cd micro-manager
git checkout mm2
&lt;/pre&gt;
&lt;p&gt;The last command switches to the mm2 branch where the Micro-Manager
2.0 source code is found. Note that it may not be necessary to install
all of the boost libraries with &lt;code&gt;sudo apt-get install
libboost-all-dev&lt;/code&gt;, but I did this anyway because I encountered
multiple errors due to missing boost library files the first few times
I tried compiling.&lt;/p&gt;
&lt;p&gt;The next step follows the normal Micro-Manager build routine using
make, with the exception of the configuration step. From inside the
Micro-Manager source code directory on the Pi, run the following
commands one at a time:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./autogen.sh
PYTHON=/usr/bin/python3 ./configure --prefix=/opt/micro-manager --with-ij-jar=/usr/share/java/ij.jar --with-python=/usr/include/python3.4 --with-boost-libdir=/usr/lib/arm-linux-gnueabihf --with-boost=/usr/include/boost
make fetchdeps
make
sudo make install
&lt;/pre&gt;
&lt;p&gt;In the configuration step, I set the Python interpreter to Python 3
because I greatly prefer it over Python 2. This is done by setting the
&lt;strong&gt;PYTHON&lt;/strong&gt; environment variable before running
configure. &lt;strong&gt;--prefix=/opt/micro-manager/&lt;/strong&gt; indicates the preferred
installation directory of
Micro-Manager. &lt;strong&gt;--with-ij-jar=/usr/share/java/ij.jar&lt;/strong&gt; is the path to
the ImageJ Java library, though I am uncertain whether this was
necessary. (I installed ImageJ with a &lt;code&gt;sudo apt-get install
imagej&lt;/code&gt; a while ago.) &lt;strong&gt;--with-python=/usr/include/python3.4&lt;/strong&gt; should
point to the directory containing the &lt;strong&gt;Python.h&lt;/strong&gt; header file for the
version of Python you are compiling against. &lt;strong&gt;with-boost-libdir&lt;/strong&gt;
should point to the directory containing the boost libraries (.so
files). This was critical for getting MM2 to build. If you are unsure
where they are located, you can search for them with &lt;code&gt;sudo find
/ -name "libboost*"&lt;/code&gt;. Finally, the last option, &lt;strong&gt;with-boost&lt;/strong&gt;, may or
may not be necessary. I set it to the directory containing the boost
headers but never checked to see whether MM compiles without it.&lt;/p&gt;
&lt;p&gt;If all goes well, Micro-Manager will compile and install without
problems. Compilation time on my Pi took around one hour.&lt;/p&gt;
&lt;div class="section" id="set-the-maximum-amount-of-direct-memory"&gt;
&lt;h3&gt;Set the maximum amount of direct memory&lt;/h3&gt;
&lt;p&gt;In the next step, we need to make a minor edit to the Micro-Manager
Linux start script. Edit the script
(/opt/micro-manager/bin/micromanager) to reduce the maximum direct
memory to something reasonable:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt/bin/java -Xmx1024M \
  -XX:MaxDirectMemorySize=1000G \
   -classpath "$CLASSPATH" \
   -Dmmcorej.library.loading.stderr.log=yes \
   -Dmmcorej.library.path="/opt/micro-manager/lib/micro-manager" \
   -Dorg.micromanager.plugin.path="/opt/micro-manager/share/micro-manager/mmplugins" \
&lt;/pre&gt;
&lt;p&gt;Change 1000G to 512M or 256M; otherwise the Pi will complain that the
MaxDirectMemorySize of 1000G is too large. You can start Micro-Manager
by running this modified script.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;Though Micro-Manager compiles and runs on the Pi, I have not yet
tested it thoroughly acquisitions. I am currently waiting on a camera
board to arrive in the mail, and when it does, I will attempt to
interface with it through Micro-Manager. Though I could write my own
Python library, Micro-Manager is appealing because it can save a lot
of time by providing a ready-made means to annotate, process, and
store imaging data.&lt;/p&gt;
&lt;p&gt;Running Micro-Manager on the Pi also raises the possibility of a fully
open, embedded biomedical imaging platform, though I am uncertain at
the moment whether the hardware on the Pi is up to the task. If you
manage to do anything cool with Micro-Manager and the Raspberry Pi,
please let me know in the comments!&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>micro-manager</category><category>microscopy</category><category>open source</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/micro-manager-on-the-raspberry-pi.html</guid><pubDate>Fri, 10 Feb 2017 18:31:57 GMT</pubDate></item><item><title>Connecting a Raspberry Pi to a home Linux network</title><link>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;I recently purchased a Raspberry Pi 3 Model B and have been tinkering
with it for a few days. One of the first things I decided to do was to
set it up so that I could access it from my laptop over my home
network. This post contains a step-by-step explanation of the
process. If you have any questions, feel free to leave a comment or
send me an e-mail.&lt;/p&gt;
&lt;div class="section" id="collect-the-necessary-information"&gt;
&lt;h2&gt;Collect the necessary information&lt;/h2&gt;
&lt;p&gt;To start, we need to collect a little bit of information about the
home network. My internet is provided by a local company that supplied
me with a Thomson TWG-870 router. This router determines the IP
addresses of all the devices on my network. Since my laptop is running
Linux (Debian Jessie, to be exact), I can use the &lt;code&gt;netstat&lt;/code&gt;
command to get the IP address of the router.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlan0
&lt;/pre&gt;
&lt;p&gt;The key part of this output is the &lt;code&gt;Gateway&lt;/code&gt; column. A gateway
is the IP address of the device (i.e. the router) that provides
devices on a local network with access to the Internet.&lt;/p&gt;
&lt;p&gt;Knowing the IP address of the gateway, we can next trying entering it
directly into the address bar of a web browser. On my machine, this
opened a dialog asking for a username and password. (If you're not
sure what these are, try asking your ISP. And if you haven't changed
them from the default settings, then you really should do this.) After
entering them and clicking &lt;strong&gt;OK&lt;/strong&gt;, the browser window displayed the
general configuration pages for the router.&lt;/p&gt;
&lt;p&gt;The next few steps will depend on the specific router. The information
we are after is the list of IP addresses that the router reserves for
static IP's. A static IP address is an address that is assigned to a
device and doesn't change. Many routers have a so-called DHCP server
that dynamically assigns IP addresses to devices such as smart phones
as they log onto the network. We probably want to always find the Pi
at the same address, however, so a static IP makes more sense than one
that the router dynamically assigns.&lt;/p&gt;
&lt;p&gt;To find the list of static IP's on my specific router, I clicked on
the link entitled &lt;strong&gt;Network&lt;/strong&gt; in my router's configuration page. The
relevant information for me looks like that in the image below:&lt;/p&gt;
&lt;img alt="DHCP address pool" class="align-center" src="http://kmdouglass.github.io/dhcp_addresses.png"&gt;
&lt;p&gt;This information is telling us that the router is reserving addresses
192.168.0.10 to 192.168.0.254 for the DHCP server. We can therefore
most probably use 192.168.0.2 through 9 for static IP's. (Remember
that 192.168.0.1 is already taken; it's the address of the router.) I
tested 192.168.0.2 by pinging it and received no response, so we will
use this address for my Raspberry Pi. (Use Ctrl-C to stop pinging the
device.):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ ping 192.168.0.2
PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.
From 192.168.0.15 icmp_seq=1 Destination Host Unreachable
From 192.168.0.15 icmp_seq=2 Destination Host Unreachable
From 192.168.0.15 icmp_seq=3 Destination Host Unreachable
^C
--- 192.168.0.2 ping statistics ---
4 packets transmitted, 0 received, +3 errors, 100% packet loss, time 3014ms
pipe 3
&lt;/pre&gt;
&lt;p&gt;For the next step, we need to collect the broadcast and subnet mask of
the network. We can do this from the laptop that is already connected
to the network by running the &lt;code&gt;sudo ifconfig&lt;/code&gt; command. This
command will report information that looks similar to the following
example (note that this is not from my machine but is merely for
illustration)::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
eth0 Link encap:Ethernet HWaddr 00:10:5A:1A:DC:65
inet addr:198.209.253.169 Bcast:208.141.109.255 Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:18940 errors:1 dropped:0 overruns:0 frame:2
TX packets:11554 errors:0 dropped:0 overruns:0 carrier:0
collisions:2 txqueuelen:100
RX bytes:4087250 (3.8 Mb) TX bytes:2499423 (2.3 Mb)
Interrupt:11 Base address:0xd000
&lt;/pre&gt;
&lt;p&gt;The very first line tells us that this block of output belongs to the
&lt;strong&gt;eth0&lt;/strong&gt; interface. If you connect to the internet on your laptop
through WiFi, then you may need to find the information for the
&lt;strong&gt;wlan0&lt;/strong&gt; interface instead. wlan0 is usually used to refer to
wireless interfaces in Ubuntu and Debian Linux.&lt;/p&gt;
&lt;p&gt;The first line of output from ifconfig also provides the type of
hardware and the ID of the ethernet card. The information we need,
however, is on the second line. The device's IP address on the network
is &lt;strong&gt;inet addr:198.209.253.169&lt;/strong&gt;, but we don't really need this
information. Rather, we need the two numbers that come next. The
broadcast IP is reported in &lt;strong&gt;Bcast:208.141.109.255&lt;/strong&gt; and the subnet
mask in &lt;strong&gt;Mask:255.255.255.0&lt;/strong&gt;. The &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Broadcast_address"&gt;broadcast IP&lt;/a&gt; is used to send
messages to all devices on the network, whereas the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Subnetwork"&gt;subnet mask&lt;/a&gt; is
used to separate the parts of an address that identify the network
from the parts that identify the devices and possible "sub-networks."&lt;/p&gt;
&lt;p&gt;To summarize this section, we need:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The static IP address that we'll assign to the Pi&lt;/li&gt;
&lt;li&gt;The IP address of the router, i.e. the gateway address&lt;/li&gt;
&lt;li&gt;The broadcast IP&lt;/li&gt;
&lt;li&gt;The subnet mask&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-pi"&gt;
&lt;h2&gt;Configure the Pi&lt;/h2&gt;
&lt;p&gt;Now that we have decided on an IP address for the Pi, let's boot it up
and configure it to always use this IP address. (I am currently using
the &lt;strong&gt;NOOBS&lt;/strong&gt; operating system that came with my Pi starter kit, but
this should work with other flavors of Debian Linux as well.)&lt;/p&gt;
&lt;p&gt;Once logged on to the Pi, open a terminal and make a backup copy of
the file &lt;strong&gt;/etc/network/interfaces&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo cp /etc/network/interfaces /etc/network/interfaces.bak
&lt;/pre&gt;
&lt;p&gt;Making a backup is good practice; in case we ruin the configuration
file, we can simply rewrite it using our backup. Next, open the
original &lt;strong&gt;interfaces&lt;/strong&gt; file for editing. In this example, I'll use
the &lt;strong&gt;nano&lt;/strong&gt; editor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo nano /etc/network/interfaces
&lt;/pre&gt;
&lt;p&gt;In this file, add the following lines (replacing the addresses with
those appropriate for your network):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
auto eth0
iface eth0 inet static
    address 192.168.0.2
    netmask 255.255.255.0
    gateway 192.168.0.1
    broadcast 192.168.0.255
&lt;/pre&gt;
&lt;p&gt;What do these lines do, you ask? Let's step through them one-by-one.&lt;/p&gt;
&lt;div class="section" id="start-the-network-interface-at-boot"&gt;
&lt;h3&gt;Start the network interface at boot&lt;/h3&gt;
&lt;p&gt;First off, we need to identify the network interface. &lt;strong&gt;eth0&lt;/strong&gt; is the
identifier that is referring to the dedicated ethernet port on the
Pi. The line &lt;strong&gt;auto eth0&lt;/strong&gt; means that this interface will be started
at boot.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-interface-to-use-a-static-ip"&gt;
&lt;h3&gt;Configure the interface to use a static IP&lt;/h3&gt;
&lt;p&gt;Next, we see the line &lt;strong&gt;iface eth0 inet static&lt;/strong&gt;. First, &lt;strong&gt;iface
eth0&lt;/strong&gt; means that we are configuring the ethernet port interface that
was described in the last section. Following that, &lt;strong&gt;inet&lt;/strong&gt; specifies
that the interface uses TCP/IP networking. Finally, &lt;strong&gt;static&lt;/strong&gt; is
telling the NOOBS operating system that the device is going to request
a static IP address from the router. (I obtained this explanation from
&lt;a class="reference external" href="http://askubuntu.com/questions/411616/what-does-keywords-in-my-etc-network-interfaces-means"&gt;this forum post&lt;/a&gt;.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="set-the-various-addresses"&gt;
&lt;h3&gt;Set the various addresses&lt;/h3&gt;
&lt;p&gt;The next lines are indented because they are properties of the &lt;strong&gt;inet
static&lt;/strong&gt; family. If you've read everything until now, you should be
able to figure out what addresses to enter next for each option. The
desired static IP address for the Pi should follow the &lt;strong&gt;address&lt;/strong&gt;
field; the subnet mask, gateway, and broadcast IP's described above
should follow &lt;strong&gt;netmask&lt;/strong&gt;, &lt;strong&gt;gateway&lt;/strong&gt;, and &lt;strong&gt;broadcast&lt;/strong&gt;
respectively.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;network&lt;/strong&gt; property (which is not shown above) contains the
network address and &lt;a class="reference external" href="http://man.cx/interfaces%285%29"&gt;is required for 2.0.x kernels&lt;/a&gt;. These kernels
are pretty old by now, so it is unlikely that you will need to specify
this property.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="restart-the-network-interface"&gt;
&lt;h3&gt;Restart the network interface&lt;/h3&gt;
&lt;p&gt;Restarting the interface we just configured on our Pi is as simple
as entering these terminal commands:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ifdown eth0
sudo ifup eth0
&lt;/pre&gt;
&lt;p&gt;(Remember to replace eth0 with the appropriate interface if yours is
different.) If everything goes well, we should be able to use our web
browser to navigate on the Internet. We should also be able to ping
the Pi from the laptop and vice versa.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="connecting-to-the-pi"&gt;
&lt;h2&gt;Connecting to the Pi&lt;/h2&gt;
&lt;p&gt;Once the Pi is on the network, we need a way to connect to it from the
laptop and other devices so that we can actually use it for
something. One way is to use &lt;a class="reference external" href="https://support.suso.com/supki/SSH_Tutorial_for_Linux"&gt;ssh&lt;/a&gt;, or Secure SHell. ssh is program
that let's us securely log on to other devices through a shell
(i.e. terminal). This is useful for when we need to work only on the
command line.&lt;/p&gt;
&lt;p&gt;If, on the other hand, we want a "Remote Desktop"-like GUI
environment, we can use &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;VNC&lt;/a&gt;. The documentation for VNC is quite
good but detailed; I'll let you read up on it on your own if you're
interested in using it.&lt;/p&gt;
&lt;p&gt;I'll now briefly explain how we can set up ssh on the Pi.&lt;/p&gt;
&lt;div class="section" id="edit-vnc-installation"&gt;
&lt;h3&gt;EDIT: VNC installation&lt;/h3&gt;
&lt;p&gt;As it turns out, you may run into some problems if you do try to setup
VNC by following the documentation in the link above. Namely, the
documentation is missing a key step, at least for me. I had to first
install the VNC server software on the Pi via:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get update
sudo apt-get install realvnc-vnc-server
&lt;/pre&gt;
&lt;p&gt;Even though the rest of this post is about ssh, you may still find
this information useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enable-ssh-on-the-pi"&gt;
&lt;h3&gt;Enable ssh on the Pi&lt;/h3&gt;
&lt;p&gt;We need to enable ssh access to the Pi before we can use it. On the
Pi, open a terminal and run the configuration utility::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo raspi-config
&lt;/pre&gt;
&lt;p&gt;We should see the following window appear.&lt;/p&gt;
&lt;img alt="The raspi-config menu with Interface Options highlighted." class="align-center" src="http://kmdouglass.github.io/pi-config-interface-options.png"&gt;
&lt;p&gt;Use the keyboard to highlight &lt;strong&gt;Interface Options&lt;/strong&gt; and tap the Enter
key. In the following menu, we now should see an option to enable ssh
as in the following image. Use the keyboard to highlight &lt;strong&gt;P2 SSH&lt;/strong&gt;
(or the relevant menu item if the name is different on your Pi) and
hit the Enter key to enable it. Once ssh is enabled, we can hit Esc or
select the &amp;lt;Back&amp;gt; option to until we exit the configuration utility.&lt;/p&gt;
&lt;img alt="The raspi-config Interface Options menu with P2 SSH highlighted." class="align-center" src="http://kmdouglass.github.io/pi-config-ssh.png"&gt;
&lt;p&gt;If you'e following along, you may need to restart your Pi for these
changes to take effect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="log-onto-the-pi-from-the-laptop"&gt;
&lt;h3&gt;Log onto the Pi from the laptop&lt;/h3&gt;
&lt;p&gt;Now for the moment of truth. After restarting the Pi, &lt;strong&gt;we need to
first ensure that we are not logged in to it&lt;/strong&gt;. If we are, simply
click the &lt;strong&gt;Menu&lt;/strong&gt; button, followed by &lt;strong&gt;Shutdown... -&amp;gt; Logout&lt;/strong&gt; and
log out of the session.&lt;/p&gt;
&lt;p&gt;Next, open a terminal on the laptop and enter the following command,
changing the IP address to whatever was decided upon for the Pi::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssh pi@192.168.0.2
&lt;/pre&gt;
&lt;p&gt;This command runs the ssh program and asks to sign into the Pi as the
user called &lt;strong&gt;pi&lt;/strong&gt;. After running the command, we may be prompted for
a password to log on if one was set on the Pi. (You did set one,
didn't you?) Once successfully entering the password, we should notice
that the terminal prompt has changed to something like
&lt;code&gt;pi@raspberrypi:~ $&lt;/code&gt;. This indicates that we are logged on to
the Pi. If we enter the &lt;code&gt;ls&lt;/code&gt; command, we should see the contents
of the Pi's home directory. When we're ready to disconnect from the
Pi, we can simply use the &lt;code&gt;exit&lt;/code&gt; command at any time in the
terminal. The prompt should change to reflect that we are back on our
laptop machine when we have successfully exited.&lt;/p&gt;
&lt;p&gt;If this is all working as described above, then congratulations on
connecting your Pi to your home Linux network! I wish you many happy
hours of hacking :)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="further-reading"&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The Debian network setup manual is very detailed and describes
many, many more aspects of setting up a network than I touched upon
here. &lt;a class="reference external" href="https://www.debian.org/doc/manuals/debian-reference/ch05.en.html"&gt;https://www.debian.org/doc/manuals/debian-reference/ch05.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Raspberry Pi documentation about VNC (Virtual Network
Computing) is a great resource for setting up a graphical interface
to remotely connect to your
Pi. &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;https://www.raspberrypi.org/documentation/remote-access/vnc/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>linux</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network.html</guid><pubDate>Sun, 05 Feb 2017 09:28:17 GMT</pubDate></item></channel></rss>