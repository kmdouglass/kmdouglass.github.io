<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Kyle M. Douglass (python)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link rel="self" href="http://kmdouglass.github.io/categories/python.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Mon, 28 Dec 2015 21:48:47 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Reading select lines from a text file</title><link>http://kmdouglass.github.io/posts/reading-select-lines-from-a-text-file.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;
&lt;a href="https://gist.github.com/kmdouglass/507717d339bc82f850ce"&gt;I just created a Python Gist&lt;/a&gt; for reading select lines from a text file
into memory. I came up with this Gist when I needed to parse the core
log from our &lt;a href="https://www.micro-manager.org/"&gt;microscope control software (Micro-Manager)&lt;/a&gt;. One of our
devices was continously sending its statistics to the computer, which
would then be recorded to the log. I wanted to find only lines that
contained the statistics by searching for the &lt;b&gt;STATS&lt;/b&gt; identifier,
which was unique to these lines.
&lt;/p&gt;

&lt;p&gt;
The problem was a bit more difficult than reading just the lines
containing this string because I wanted the statistics only for times
when the software was acquiring a time series of images. Luckily, the
core log also contains lines with unique strings indicating when a
time series was initiated and stopped. All lines in the log are
time-stamped.
&lt;/p&gt;

&lt;p&gt;
Below is the Gist I used to solve this problem. The lines that will be
retained in memory will contain the strings in the list lineFilters. I
then define a function named stringIsIn that will return a list of
bool indicating whether each string is present in the line.
&lt;/p&gt;

&lt;p&gt;
At the bottom of the Gist, I use a list comprehension to loop over
each line in the file. The line is appended to a growing list called
outputLines if the line contains &lt;i&gt;any&lt;/i&gt; of the strings I defined. Note
that it's not necessary to use a separate definition for stringIsIn;
the list comprehension over lineFilters could have been placed inline
with the primary list comprension over lines in the file. I do think
it is more readable the way it is presented below, however.
&lt;/p&gt;

&lt;p&gt;
I welcome any comments or suggestions, especially on the &lt;a href="https://gist.github.com/kmdouglass/507717d339bc82f850ce"&gt;Gist website&lt;/a&gt;
where others may be more likely to find it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;filename&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'myFile.txt'&lt;/span&gt;
&lt;span class="n"&gt;outputLines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="c"&gt;# Keep all lines containing ANY of the following list of strings.&lt;/span&gt;
&lt;span class="n"&gt;lineFilters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'line 1'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	       &lt;span class="s"&gt;'line 2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	       &lt;span class="s"&gt;'line 3'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;stringIsIn&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;filter&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lineFilters&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;


&lt;span class="c"&gt;# Read only lines containing one of the strings into memory.&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;'r'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;outputLines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;any&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stringIsIn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>micro-manager</category><category>python</category><guid>http://kmdouglass.github.io/posts/reading-select-lines-from-a-text-file.html</guid><pubDate>Wed, 18 Mar 2015 07:27:50 GMT</pubDate></item><item><title>The basics of virtualenv</title><link>http://kmdouglass.github.io/posts/the-basics-of-virtualenv.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;
I use Python 3.4 in most of my data analyses and in some
simulations. I like a lot of its features, like its implementation of
generators, maps, and filters. However, much of the software on my
Debian Wheezy system depends on Python 2.7 to run, such as
&lt;a href="http://www.mendeley.com/"&gt;Mendeley&lt;/a&gt;. (It used to run just fine with Python 3.4, until I ran an
automatic update and that was the end of that.)
&lt;/p&gt;

&lt;p&gt;
To run some Python 2.7 programs, I used to do the following:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;sudo rm /usr/bin/python 
sudo ln -s /usr/bin/python2.7 /usr/bin/python
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
I know. Ouch. Every single time I needed to run a program that
depended on python2.7, I would delete the symlink in /usr/bin, make a
new link to python2.7, and then run my program. When I needed to give
various programs convenient access to python3.4, I would delete the
symlink and create a new one to the newer version.
&lt;/p&gt;

&lt;p&gt;
This was dumb, because there is a convenient Python-based tool that
can fix the problem of needing multiple versions of Python (and
libraries!) on the same system. The solution to this problem is called
&lt;a href="https://virtualenv.pypa.io/en/latest/"&gt;virtualenv&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
There are a lot of descriptions about what virtualenv is on the
internet, so I won't bother going into details here. Instead, I will
focus on just the very basics of its setup and use so that I can have
a handy future reference for when I forget how something works and so
that others can profit from what I have learned. Most everything I've
done came from &lt;a href="http://docs.python-guide.org/en/latest/"&gt;python-guide.org&lt;/a&gt;, so I'm more-or-less putting &lt;a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/"&gt;what they
have already said&lt;/a&gt; into my own words.
&lt;/p&gt;

&lt;p&gt;
To start, I already have Python 2.7 and 3.4 installed on my system. In
principle, you do not need them installed at the system level, but I
already have done this so I will start from there. I first installed
pip for Python 2.7 since I only had pip3 on my system to start. I did
this because I want to keep Python 2.7 as my system's default Python
environment.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get update
sudo apt-get install python-pip
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Once installed, I used it to install virtualenv and
&lt;a href="https://virtualenvwrapper.readthedocs.org/en/latest/"&gt;virtualenvwrapper&lt;/a&gt;. The latter provides some nice features for working
with virtualenv.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;sudo pip install virtualenv
sudo pip install virtualenvwrapper
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now, virtualenvwrapper requires an environment variable to tell it
where to store the folders for each virtual environment. This
environment variable is called WORKON_HOME. First, I created the
folder it will point to:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;mkdir ~/Envs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Next, I edited my ~/.bashrc and added the following line:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;WORKON_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;~/Envs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
All of my virtual environment files (except for the Python
intepreters) will be stored in this folder. Finally, I restarted my
terminal window so that the environment variable was assigned. You can
check this by typing &lt;code&gt;echo $WORKON_HOME&lt;/code&gt; in your new terminal
window. If it returns the path to your new environments folder, then
you should be fine.
&lt;/p&gt;

&lt;p&gt;
Next, I ran the virtualwrapper setup script. Note that I did not need
sudo (in fact, sudo could not find a command called ``source'') and
that no output is returned when the script is run.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;source&lt;/span&gt; /usr/local/bin/virtualenvwrapper.sh
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now virtualenvwrapper should be installed, so let's make a virtual
environment. We can do this using the &lt;code&gt;mkvirtualenv&lt;/code&gt; command, followed
by a name for the environment. I will use the name ``venv'' in this
example, like Kenneth Reitz did in his guide that I linked above.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;mkvirtualenv venv
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
To start the new virtual environment, type &lt;code&gt;workon venv&lt;/code&gt; and note that
change in the prompt, indicating which environment you are in. You now
have a fresh Python environment to which you can add any library you
wish. To leave the environment, type &lt;code&gt;deactivate&lt;/code&gt; into your terminal.
&lt;/p&gt;

&lt;p&gt;
One simple test that you can do to see whether your Python environment
really is clean is to run the Python interpreter from inside your
environment and try importing a module that you know is in your
system-wide site packages but not in your virtual environment. For
example, inside venv I type &lt;code&gt;python&lt;/code&gt; at the terminal prompt and tried
importing numpy, which I had not yet installed in venv:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This returned an &lt;b&gt;ImportError: No module named numpy&lt;/b&gt;. Since I do have
numpy installed on my system but not in this environment, it tells me
that the environment is likely clean.
&lt;/p&gt;

&lt;p&gt;
To install new libraries, simply use pip or install them to the folder
that was created for this environment in ~/Env. To delete a virtual
environment entirely, use &lt;code&gt;rmvirtual env&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Now, how can I specify that I want the virtual environment to use the
python3.4 interpreter in a virtual environment named
``python3-general''? Doing so would solve my original problem. Simply
make a new virtual environment like so:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkvirtualenv&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;python3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="n"&gt;python3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;general&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Voilà. C'est tout. I hope this helps you get up and running with this
great tool!
&lt;/p&gt;</description><category>python</category><guid>http://kmdouglass.github.io/posts/the-basics-of-virtualenv.html</guid><pubDate>Tue, 10 Feb 2015 06:47:50 GMT</pubDate></item><item><title>Sending arguments to Python decorators</title><link>http://kmdouglass.github.io/posts/sending-arguments-to-python-decorators.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;
&lt;a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/"&gt;Python's decorators&lt;/a&gt; are tools for changing the behavior of a function
without completely recoding it. When we apply a decorator to a
function, we say that the function has been decorated. Strictly
speaking, when we decorate a function, we send it to a wrapper that
returns another function. It's as simple as that.
&lt;/p&gt;

&lt;p&gt;
I was having trouble understanding exactly to which function, the
original or the decorated one, the arguments are sent in a Python
decorated function call. I wrote the following script to better
understand this process (I use Python 3.4):
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inFunction&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'The input arguments were:'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
	    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'&lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt; : &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt;'&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

	&lt;span class="c"&gt;# Return the original function&lt;/span&gt;
	&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inFunction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;outFunction&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;wrapper(inFunction)&lt;/code&gt; is a function that accepts another function as
an argument. It returns a function that simply prints the keyword
arguments of &lt;i&gt;inFunction()&lt;/i&gt;, and calls &lt;i&gt;inFunction()&lt;/i&gt; like normal.
&lt;/p&gt;

&lt;p&gt;
To decorate the function &lt;i&gt;add(x = 1, y = 2)&lt;/i&gt; so that its arguments are
printed without recoding it, we normally would place &lt;code&gt;@wrapper&lt;/code&gt; before
its definition. However, let's make the decorator in a way that's
closer to how &lt;i&gt;@&lt;/i&gt; works under the hood:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;In [22]: decoratedAdd = wrapper(add)
In [23]: decoratedAdd(x = 1, y = 24)
The input arguments were:
'y' : 24
'x' : 1
Out[23]: 25
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When we call &lt;i&gt;decoratedAdd(x = 1, y = 24)&lt;/i&gt;, the arguments are printed
to the screen and we still get the same functionality of &lt;i&gt;add()&lt;/i&gt;. What
I wanted to know was this: are the keyword arguments x = 1, y = 24
bound in the namespace of &lt;i&gt;wrapper()&lt;/i&gt; or in the namespace of
&lt;i&gt;outFunction()&lt;/i&gt;? &lt;b&gt;In otherwords, does &lt;i&gt;wrapper()&lt;/i&gt; at any point know
what the arguments are that I send to the decorated function?&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
The answer, as it turns out, is no in this case. This is because the
&lt;i&gt;wrapper()&lt;/i&gt; function first returns the decorated function, and then
the arguments are passed into the decorated function. If this order of
operations were flipped, &lt;i&gt;wrapper()&lt;/i&gt; should know that I set x to 1 and
y to 24, but really it doesn't know these details at all.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;In [24]: wrapper(add)(x = 1, y = 24)
The input arguments were:
'y' : 24
'x' : 1
Out[24]: 25
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
So, when I call &lt;i&gt;wrapper(add)(x = 1, y = 24)&lt;/i&gt;, first &lt;i&gt;wrapper(add)&lt;/i&gt; is
called, which returns &lt;i&gt;outFunction()&lt;/i&gt;, and then these arguments are
passed to &lt;i&gt;outFunction()&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
Now what happens when I call &lt;code&gt;wrapper(add(x = 1, y = 24))&lt;/code&gt;? When I try
this, the arguments are first passed into add, but then &lt;i&gt;outFunction&lt;/i&gt;
is returned without any arguments applied to it.
&lt;/p&gt;

&lt;p&gt;
This example can give us an idea about the working order of operations
in Python. Here, this example reveals that function calls in Python
are left-associative.
&lt;/p&gt;</description><category>python</category><guid>http://kmdouglass.github.io/posts/sending-arguments-to-python-decorators.html</guid><pubDate>Sat, 24 Jan 2015 07:45:38 GMT</pubDate></item><item><title>Learning Python's Multiprocessing Module</title><link>http://kmdouglass.github.io/posts/learning-pythons-multiprocessing-module.html</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;p&gt;
I've been doing a bit of programming work lately that would greatly
benefit from a speed boost using parallel/concurrent processing
tools. Essentially, I'm doing a &lt;a href="http://www.mathworks.com/help/simulink/examples/parallel-simulations-using-parfor-parameter-sweep-in-normal-mode.html"&gt;parameter sweep&lt;/a&gt; where the values for
two different simulation parameters are input into the simulation and
allowed to run with the results being recorded to disk at the end. The
point is to find out how the simulation results vary with the
parameter values.
&lt;/p&gt;

&lt;p&gt;
In my current code, a new simulation is initialized with each pair of
parameter values inside one iteration of a for loop; each iteration of
the loop is independent of the others. Spreading these iterations over
the 12 cores on my workstation should result in about a 12x decrease
in the amount of time the simulation takes to run.
&lt;/p&gt;

&lt;p&gt;
I've had good success using the &lt;code&gt;parfor&lt;/code&gt; loop construct in Matlab in
the past, but my simulation was written in Python and I want to learn
more about Python's multiprocessing tools, so this post will explore
that module in the context of performing parameter sweeps.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Profile the code first to identify bottlenecks&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
First, I profiled my code to identify where any slowdowns might be
occurring in the serial program. I used a great tutorial at the &lt;a href="https://zapier.com/engineering/profiling-python-boss/"&gt;Zapier
Engineering&lt;/a&gt; blog to write a decorator for profiling the main instance
method of my class that was doing most of the work. Surprisingly, I
found that a few numpy methods were taking the most time, namely
&lt;b&gt;norm()&lt;/b&gt; and &lt;b&gt;cross()&lt;/b&gt;. To address this, I directly imported the
Fortran BLAS &lt;b&gt;nrm2()&lt;/b&gt; function using scipy's &lt;b&gt;get_blas_funcs()&lt;/b&gt;
function and hard-coded the cross product in pure Python inside the
method; these two steps alone resulted in a 4x decrease in simulation
time. I suspect the reason for this was because the overhead of
calling functions on small arrays outweighs the increase in speed
using Numpy's optimized C code. I was normalizing single vectors and
taking cross products between two vectors at a time many times during
each loop iteration.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;A brief glance at Python's multiprocessing module&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
&lt;a href="http://pymotw.com/2/multiprocessing/basics.html"&gt;PyMOTW&lt;/a&gt; has a good, minimal description of the main aspects of the
multiprocessing module. They state that the simplest way to create
tasks on different cores of a machine is to create new &lt;b&gt;Process&lt;/b&gt;
objects with target functions. Each object is then set to execute by
calling its &lt;b&gt;start()&lt;/b&gt; method.
&lt;/p&gt;

&lt;p&gt;
The basic example from their site looks like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""worker function"""&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;'Worker'&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;jobs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;worker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;jobs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In this example, it's important to create the Process instances inside
the
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
section of the script because child processes import the script where
the target function is contained. Placing the object instantiation in
this section prevents an infinite, recursive string of such
instantiations. A workaround to this is to define the function in a
different script and import it into the namespace.
&lt;/p&gt;

&lt;p&gt;
To send arguments to the function (&lt;b&gt;worker()&lt;/b&gt; in the example above),
we can use the &lt;b&gt;args&lt;/b&gt; keyword in the Process object instantiation like
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;p = multiprocessing.Process(target=worker, args=(i,))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
A very important thing to note is that the arguments must be objects
that can be pickled using Python's pickle module. If an argument is a
class instance, this means that every attritube of that class must be
pickleable.
&lt;/p&gt;

&lt;p&gt;
An important class in the multiprocessing module is a &lt;b&gt;Pool&lt;/b&gt;. A &lt;a href="https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.pool.Pool"&gt;Pool&lt;/a&gt;
object controls a pool of worker processes. Jobs can be submitted to
the Pool, which then sends the jobs to the individual workers.
&lt;/p&gt;

&lt;p&gt;
The &lt;b&gt;Pool.map()&lt;/b&gt; achieves the same functionality as Matlab's &lt;b&gt;parfor&lt;/b&gt;
construct. This method essentially applies a function to each element
in an iterable and returns the results. For example, if I wanted to
square each number in a list of integers between 0 and 9 and perform
the square operation on multiple processors, I would write a function
for squaring an argument, and supply this function and the list of
integers to &lt;b&gt;Pool.map()&lt;/b&gt;. The code looks like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;funSquare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pool&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;funSquare&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;Design the solution to the problem&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
In my parameter sweep, I have two classes: one is an object that I'm
simulating and the other acts as a controller that sends parameters to
the structure and collects the results of the simulation. Everything
was written in a serial fashion and I want to change it so the bulk of
the work is performed in parallel.
&lt;/p&gt;

&lt;p&gt;
After the bottlenecks were identified in the serial code, I began
thinking about how the the problem of parameter sweeps could be
addressed using the multiprocessing module.
&lt;/p&gt;

&lt;p&gt;
The solution requirements I identified for my parameter sweep are as
follows:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Accept two values (one for each parameter) from the range of values
to test as inputs to the simulation.
&lt;/li&gt;
&lt;li&gt;For each pair of values, run the simulation as an independent
process.
&lt;/li&gt;
&lt;li&gt;Return the results of the simulation as as a list or Numpy array.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
I often choose to return the results as Numpy arrays since I can
easily pickle them when saving to a disk. This may change depending on
your specific problem.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;Implementation of the solution&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
I'll now give a simplified example of how this solution to the
parameter sweep can be implemented using Python's multiprocessing
module. I won't use objects like in my real code, but will first
demonstrate an example where &lt;b&gt;Pool.map()&lt;/b&gt; is applied to a list of
numbers.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""This is the main processing function. It will contain whatever&lt;/span&gt;
&lt;span class="sd"&gt;    code should be run on multiple processors.&lt;/span&gt;

&lt;span class="sd"&gt;    """&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;
    &lt;span class="c"&gt;# Example computation&lt;/span&gt;
    &lt;span class="n"&gt;processedData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;processedData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;processedData&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# Define the parameters to test&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;202&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# Zip the parameters because pool.map() takes only one iterable&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pool&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is a rather silly example of a simulation, but I think it
illustrates the point nicely. In the &lt;b&gt;&lt;span class="underline"&gt;&lt;span class="underline"&gt;main&lt;/span&gt;&lt;/span&gt;&lt;/b&gt; portion of the code, I
first define two lists for each parameter value that I want to
'simulate.' These parameters are zipped together in this example
because &lt;b&gt;Pool.map()&lt;/b&gt; takes only one iterable as its argument. The pool
is opened using with &lt;b&gt;multiprocessing.Pool()&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
Most of the work is performed in the function
&lt;b&gt;runSimulation(params)&lt;/b&gt;. It takes a tuple of two parameters which are
unpacked. Then, these parameters are used in the for loop to build a
list of simulated values which is eventually returned.
&lt;/p&gt;

&lt;p&gt;
Returning to the &lt;b&gt;&lt;span class="underline"&gt;&lt;span class="underline"&gt;main&lt;/span&gt;&lt;/span&gt;&lt;/b&gt; section, each simulation is run on a
different core of my machine using the &lt;b&gt;Pool.map()&lt;/b&gt; function. This
applies the function called &lt;b&gt;runSimulation()&lt;/b&gt; to the values in the
&lt;b&gt;params&lt;/b&gt; iterable. In other words, it calls the code described in
&lt;b&gt;runSimulation()&lt;/b&gt; with a different pair of values in params.
&lt;/p&gt;

&lt;p&gt;
All the results are eventually returned in a list in the same order as
the parameter iterable. This means that the first element in the
&lt;b&gt;results&lt;/b&gt; list corresponds to parameters of 0 and 2 in this example.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;Iterables over arbitrary objects&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
In my real simulation code, I use a class to encapsulate a number of
structural parameters and methods for simulating a polymer model. So
long as instances of this class can be &lt;a href="https://docs.python.org/3/library/pickle.html"&gt;pickled&lt;/a&gt;, I can use them as the
iterable in &lt;b&gt;Pool.map()&lt;/b&gt;, not just lists of floating point numbers.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;simObject&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;objInstance&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""This is the main processing function. It will contain whatever&lt;/span&gt;
&lt;span class="sd"&gt;    code should be run on multiple processors.&lt;/span&gt;

&lt;span class="sd"&gt;    """&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;objInstance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;objInstance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;param2&lt;/span&gt;
    &lt;span class="c"&gt;# Example computation&lt;/span&gt;
    &lt;span class="n"&gt;processedData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;processedData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;processedData&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# Define the parameters to test&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;202&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;objList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="c"&gt;# Create a list of objects to feed into pool.map()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;objList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;simObject&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pool&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;objList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Again, this is a silly example, but it demonstrates that lists of
objects can be used in the parameter sweep, allowing for easy
parallelization of object-oriented code.
&lt;/p&gt;

&lt;p&gt;
Instead of &lt;b&gt;runSimulation()&lt;/b&gt;, you may want to apply an instance method
to a list in &lt;b&gt;pool.map()&lt;/b&gt;. A naïve way to do this is to replace
&lt;b&gt;runSimulation&lt;/b&gt; with with the method name but this too causes
problems. I won't go into the details here, but one solution is to use
an instance's &lt;b&gt;__call__()&lt;/b&gt; method and pass the object instance into
the pool. More details can be found &lt;a href="http://stackoverflow.com/questions/1816958/cant-pickle-type-instancemethod-when-using-pythons-multiprocessing-pool-ma"&gt;here&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;Comparing computation times&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
The following code makes a rough comparison between computation time
for the parallel and serial versions of &lt;b&gt;map()&lt;/b&gt;:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""This is the main processing function. It will contain whatever&lt;/span&gt;
&lt;span class="sd"&gt;    code should be run on multiple processors.&lt;/span&gt;

&lt;span class="sd"&gt;    """&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;
    &lt;span class="c"&gt;# Example computation&lt;/span&gt;
    &lt;span class="n"&gt;processedData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
	&lt;span class="n"&gt;processedData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;processedData&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# Define the parameters to test&lt;/span&gt;
    &lt;span class="n"&gt;param1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;param2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;202&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;pool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multiprocessing&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pool&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c"&gt;# Parallel map&lt;/span&gt;
    &lt;span class="n"&gt;tic&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;toc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="c"&gt;# Serial map&lt;/span&gt;
    &lt;span class="n"&gt;tic2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runSimulation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;toc2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'Parallel processing time: &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;Serial processing time: &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s"&gt;'&lt;/span&gt;
	  &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;tic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;toc2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;tic2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
On my machine, &lt;b&gt;pool.map()&lt;/b&gt; ran in 9.6 seconds, but the serial version
took 163.3 seconds. My laptop has 8 cores, so I would have expected
the speedup to be a factor of 8, not a factor of 16. I'm not sure why
it's 16, but I suspect part of the reason is that measuring system
time using the &lt;b&gt;time.time()&lt;/b&gt; function is not wholly accurate.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;Important points&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;p&gt;
I can verify that all the cores are being utilized on my machine while
the code is running by using the &lt;a href="http://hisham.hm/htop/"&gt;htop&lt;/a&gt; console program. In some cases,
Python modules like Numpy, scipy, etc. may limit processes in Python
to running on only one core on Linux machines, which defeats the
purpose of writing concurrent code in this case. (See for example &lt;a href="http://stackoverflow.com/questions/15639779/what-determines-whether-different-python-processes-are-assigned-to-the-same-or-d/15641148#15641148"&gt;this
discussion&lt;/a&gt;.) To fix this, we can import Python's &lt;b&gt;os&lt;/b&gt; module to reset
the task affinity in our code:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"taskset -p 0xff &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-8" class="outline-2"&gt;
&lt;h2 id="sec-8"&gt;Conclusions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
I think that Matlab's &lt;b&gt;parfor&lt;/b&gt; construct is easier to use because one
doesn't have to consider the nuances of writing concurrent code. So
long as each loop iteration is independent of the others, you simply
write a &lt;b&gt;parfor&lt;/b&gt; instead of &lt;b&gt;for&lt;/b&gt; and you're set.
&lt;/p&gt;

&lt;p&gt;
In Python, you have to prevent infinite, recursive function calls by
placing your code in the &lt;b&gt;&lt;span class="underline"&gt;&lt;span class="underline"&gt;main&lt;/span&gt;&lt;/span&gt;&lt;/b&gt; section of your script or by
placing the function in a different script and importing it. You also
have to be sure that Numpy and other Python modules that use BLAS
haven't reset the core affinity. What you gain over Matlab's
implementation is the power of using Python as a general programming
language with a lot of tools for scientific computing. This and the
multiprocessing module is free; you have to have an institute license
or pay for Matlab's &lt;a href="http://www.mathworks.com/products/parallel-computing/"&gt;Parallel Computing Toolbox&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computing</category><category>python</category><guid>http://kmdouglass.github.io/posts/learning-pythons-multiprocessing-module.html</guid><pubDate>Mon, 29 Dec 2014 17:42:23 GMT</pubDate></item></channel></rss>