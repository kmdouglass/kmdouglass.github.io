<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kyle M. Douglass (Posts about linux)</title><link>http://kmdouglass.github.io/</link><description></description><atom:link href="http://kmdouglass.github.io/categories/linux.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 26 Feb 2019 18:34:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A simple UNIX socket listener in Rust</title><link>http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;I decided that I wanted to learn a new programming language in 2019. After a bit of research, I
settled upon &lt;a class="reference external" href="https://www.rust-lang.org/"&gt;Rust&lt;/a&gt; due to its speed, novel ideas about memory safety, and &lt;a class="reference external" href="https://blog.rust-lang.org/2018/03/12/roadmap.html#four-target-domains"&gt;focus on two areas
that I am interested in&lt;/a&gt;: embedded systems and WebAssembly. While I think that &lt;a class="reference external" href="https://doc.rust-lang.org/book/"&gt;The Book&lt;/a&gt; is the
best place to get started learning the language, nothing is a really a substitute for writing
code.&lt;/p&gt;
&lt;p&gt;With that in mind, I developed an idea for a starting project: a background daemon for Linux
systems like the Raspberry Pi that controls and reads data from the system's peripherals. The
design of this project is inspired by Docker: a daemon process does most of the heavy work while a
command line tool communicates with the Daemon over a Unix socket (typically a file located at
&lt;tt class="docutils literal"&gt;/var/run/docker.sock&lt;/tt&gt;). The purpose of this post is to demonstrate the most basic realization of
this: reading text from a UNIX socket in Rust. And to emphasize that the UNIX socket is used for
communication between two separate processes, we will send messages from Bash to Rust.&lt;/p&gt;
&lt;p&gt;Keep in mind that this is my first-ever Rust program, so it may not be completely idiomatic
Rust. The following was compiled with rustc 1.32.0 (9fda7c223 2019-01-16).&lt;/p&gt;
&lt;p&gt;To begin, I created a new Rust project with &lt;tt class="docutils literal"&gt;cargo&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="code shell"&gt;&lt;a name="rest_code_fdfc39b8b2ec45d0be43d9d75dd8a438-1"&gt;&lt;/a&gt;$ cargo new rust-uds
&lt;a name="rest_code_fdfc39b8b2ec45d0be43d9d75dd8a438-2"&gt;&lt;/a&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; rust-uds
&lt;/pre&gt;&lt;p&gt;Next, I opened the file that cargo automatically generated in &lt;tt class="docutils literal"&gt;src/main.rs&lt;/tt&gt;, removed the
auto-generated content, and added the following code, which is largely based on the &lt;a class="reference external" href="https://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#examples"&gt;example&lt;/a&gt;
provided in the Rust documentation but with a few key differences:&lt;/p&gt;
&lt;table class="codetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-1"&gt; 1&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-2"&gt; 2&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-3"&gt; 3&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-4"&gt; 4&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-5"&gt; 5&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-6"&gt; 6&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-7"&gt; 7&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-8"&gt; 8&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-9"&gt; 9&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-10"&gt;10&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-11"&gt;11&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-12"&gt;12&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-13"&gt;13&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-14"&gt;14&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-15"&gt;15&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-16"&gt;16&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-17"&gt;17&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-18"&gt;18&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-19"&gt;19&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-20"&gt;20&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-21"&gt;21&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-22"&gt;22&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-23"&gt;23&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-24"&gt;24&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-25"&gt;25&lt;/a&gt;
&lt;a href="http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/#rest_code_4c11b8c78c5f4e9ebf425ad95fece225-26"&gt;26&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre class="code rust"&gt;&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;io&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-2"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;os&lt;/span&gt;::&lt;span class="n"&gt;unix&lt;/span&gt;::&lt;span class="n"&gt;net&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-4"&gt;&lt;/a&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-5"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;: &lt;span class="nc"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-6"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-7"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-8"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-9"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-10"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-12"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-13"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;::&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/tmp/rust-uds.sock"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-15"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incoming&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-16"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-17"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-18"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;::&lt;span class="n"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-19"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-20"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-21"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Error: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-22"&gt;&lt;/a&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-23"&gt;&lt;/a&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-24"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-25"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_4c11b8c78c5f4e9ebf425ad95fece225-26"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;div class="section" id="explanation"&gt;
&lt;h2&gt;Explanation&lt;/h2&gt;
&lt;p&gt;The first three lines import the necessary modules for this code example.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_28c734edfd9f4eb3b8d13472db04a609-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;io&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_28c734edfd9f4eb3b8d13472db04a609-2"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;os&lt;/span&gt;::&lt;span class="n"&gt;unix&lt;/span&gt;::&lt;span class="n"&gt;net&lt;/span&gt;::&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_28c734edfd9f4eb3b8d13472db04a609-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;&lt;tt class="docutils literal"&gt;BufRead&lt;/tt&gt; is a trait that enables extra ways of reading data sources; in this case, it has an
internal buffer for reading the socket line-by-line. &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt; is a struct that actually
implements the functionality in &lt;tt class="docutils literal"&gt;BufRead&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;UnixStream&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;UnixListener&lt;/tt&gt; are structs that
provide the functionality for handling the UNIX socket, and the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::thread&lt;/span&gt;&lt;/tt&gt; module is used to
spawn threads.&lt;/p&gt;
&lt;p&gt;The next set of lines defines a function named &lt;tt class="docutils literal"&gt;handle_client()&lt;/tt&gt; that is called whenever new data
arrives in the stream. The explanation for this is best left until after the &lt;tt class="docutils literal"&gt;main()&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;The first line in the &lt;tt class="docutils literal"&gt;main()&lt;/tt&gt; function creates the UnixListener struct and binds it to the
&lt;tt class="docutils literal"&gt;listener&lt;/tt&gt; variable.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_95c55c4496d94d7bbcde824919b048f6-1"&gt;&lt;/a&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UnixListener&lt;/span&gt;::&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/tmp/rust-uds.sock"&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The &lt;tt class="docutils literal"&gt;bind()&lt;/tt&gt; function takes a string argument that is a path to the socket file and &lt;tt class="docutils literal"&gt;unwrap()&lt;/tt&gt;
moves the value out of the Result that is returned by &lt;tt class="docutils literal"&gt;bind()&lt;/tt&gt;. (This is a pattern that is
&lt;a class="reference external" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"&gt;discouraged&lt;/a&gt; in Rust but is OK for quick prototypes because it simplifies the error handling.)&lt;/p&gt;
&lt;p&gt;After creating the listener, &lt;tt class="docutils literal"&gt;listener.incoming()&lt;/tt&gt; returns an iterator over the incoming
connections to the socket. The connections are looped over in an infinite for loop; I believe that
this is more-or-less the same as a generator in Python which never raises a &lt;tt class="docutils literal"&gt;StopIteration&lt;/tt&gt;
exception.&lt;/p&gt;
&lt;p&gt;Next, the &lt;tt class="docutils literal"&gt;Result&lt;/tt&gt; of the incoming streams is matched; if there is an error, it is printed and
the loop it exited:&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_1da1ba5f221c4159bc42f36a76f0ce2b-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_1da1ba5f221c4159bc42f36a76f0ce2b-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Error: {}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_1da1ba5f221c4159bc42f36a76f0ce2b-3"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_1da1ba5f221c4159bc42f36a76f0ce2b-4"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;However, if the &lt;tt class="docutils literal"&gt;Result&lt;/tt&gt; of the connection is &lt;tt class="docutils literal"&gt;Ok&lt;/tt&gt;, then a new thread is spawned to handle the
new stream:&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_65ed67bd835b439fb097d574655ca37d-1"&gt;&lt;/a&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_65ed67bd835b439fb097d574655ca37d-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;::&lt;span class="n"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_65ed67bd835b439fb097d574655ca37d-3"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Finally, the client handler is called for each connection.&lt;/p&gt;
&lt;pre class="code rust"&gt;&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;: &lt;span class="nc"&gt;UnixStream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-2"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BufReader&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-3"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-4"&gt;&lt;/a&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"{}"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-5"&gt;&lt;/a&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;a name="rest_code_3dd2c0b9e1584280b25559f4f4931d7d-6"&gt;&lt;/a&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;The handler in this case is fairly straight-forward. It shadows the original &lt;tt class="docutils literal"&gt;stream&lt;/tt&gt; variable by
binding it to a version of itself that has been converted to a &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;. Finally, it loops
over the &lt;tt class="docutils literal"&gt;lines()&lt;/tt&gt; iterator, which blocks until a new line appears in the stream.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sending-messages"&gt;
&lt;h2&gt;Sending messages&lt;/h2&gt;
&lt;p&gt;As an example, let's send messages to the Rust program via Bash using &lt;a class="reference external" href="http://man.openbsd.org/nc"&gt;the OpenBSD version of
netcat&lt;/a&gt;. (The OpenBSD version seems to be the default on Ubuntu-based systems.) This should
underscore the fact that the UNIX socket is really being used to communicate between two different
processes.&lt;/p&gt;
&lt;p&gt;First, compile and run the Rust program to start the socket listener:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_764823c4e09248dfa918e6f704325997-1"&gt;&lt;/a&gt;$ cargo run --release
&lt;a name="rest_code_764823c4e09248dfa918e6f704325997-2"&gt;&lt;/a&gt;   Compiling rust-uds v0.1.0 (/home/kmd/src/rust-uds)
&lt;a name="rest_code_764823c4e09248dfa918e6f704325997-3"&gt;&lt;/a&gt;    Finished release [optimized] target(s) in 1.59s
&lt;a name="rest_code_764823c4e09248dfa918e6f704325997-4"&gt;&lt;/a&gt;     Running `target/release/rust-uds`
&lt;/pre&gt;&lt;p&gt;Open up a new terminal. You should see the socket file /tmp/rust-uds.sock:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_df8f989109c74c8e95ed22e17d0b0095-1"&gt;&lt;/a&gt;$ ls /tmp | grep rust
&lt;a name="rest_code_df8f989109c74c8e95ed22e17d0b0095-2"&gt;&lt;/a&gt;rust-uds.sock
&lt;/pre&gt;&lt;p&gt;Now let's send messages to the rust program. Use the following netcat command to open a connection
to the socket.&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_02aab62732624e62a2054cf0a5433f74-1"&gt;&lt;/a&gt;$ nc -U /tmp/rust-uds.sock
&lt;/pre&gt;&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-U&lt;/span&gt;&lt;/tt&gt; is necessary to indicate to netcat that this is a UNIX stream socket. Now, start typing
text into the same window. Every time you press ENTER, you should see the same text appear in the
terminal window in which the Rust program is running. Press CTRL-C to exit the Rust socket
listener. If you re-run the program, delete the old socket first: &lt;tt class="docutils literal"&gt;rm &lt;span class="pre"&gt;/tmp/rust-uds.sock&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use a &lt;tt class="docutils literal"&gt;UnixListener&lt;/tt&gt; struct to create a UNIX socket and listen to it for connections.&lt;/li&gt;
&lt;li&gt;For each new connection, spawn a new thread and read the stream with a &lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Print each new line in the stream by iterating over the &lt;tt class="docutils literal"&gt;lines()&lt;/tt&gt; iterator of the
&lt;tt class="docutils literal"&gt;BufReader&lt;/tt&gt;.&lt;/li&gt;
&lt;li&gt;Send commands to your Rust program from bash with &lt;tt class="docutils literal"&gt;nc &lt;span class="pre"&gt;-U&lt;/span&gt; "$PATH_TO_SOCKET"&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>linux</category><category>rust</category><guid>http://kmdouglass.github.io/posts/a-simple-unix-socket-listener-in-rust/</guid><pubDate>Sun, 24 Feb 2019 15:25:58 GMT</pubDate></item><item><title>Connecting a Raspberry Pi to a home Linux network</title><link>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network/</link><dc:creator>Kyle M. Douglass</dc:creator><description>&lt;div&gt;&lt;p&gt;I recently purchased a Raspberry Pi 3 Model B and have been tinkering
with it for a few days. One of the first things I decided to do was to
set it up so that I could access it from my laptop over my home
network. This post contains a step-by-step explanation of the
process. If you have any questions, feel free to leave a comment or
send me an e-mail.&lt;/p&gt;
&lt;div class="section" id="collect-the-necessary-information"&gt;
&lt;h2&gt;Collect the necessary information&lt;/h2&gt;
&lt;p&gt;To start, we need to collect a little bit of information about the
home network. My internet is provided by a local company that supplied
me with a Thomson TWG-870 router. This router determines the IP
addresses of all the devices on my network. Since my laptop is running
Linux (Debian Jessie, to be exact), I can use the &lt;code&gt;netstat&lt;/code&gt;
command to get the IP address of the router.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.0.1     0.0.0.0         UG        0 0          0 wlan0
&lt;/pre&gt;
&lt;p&gt;The key part of this output is the &lt;code&gt;Gateway&lt;/code&gt; column. A gateway
is the IP address of the device (i.e. the router) that provides
devices on a local network with access to the Internet.&lt;/p&gt;
&lt;p&gt;Knowing the IP address of the gateway, we can next trying entering it
directly into the address bar of a web browser. On my machine, this
opened a dialog asking for a username and password. (If you're not
sure what these are, try asking your ISP. And if you haven't changed
them from the default settings, then you really should do this.) After
entering them and clicking &lt;strong&gt;OK&lt;/strong&gt;, the browser window displayed the
general configuration pages for the router.&lt;/p&gt;
&lt;p&gt;The next few steps will depend on the specific router. The information
we are after is the list of IP addresses that the router reserves for
static IP's. A static IP address is an address that is assigned to a
device and doesn't change. Many routers have a so-called DHCP server
that dynamically assigns IP addresses to devices such as smart phones
as they log onto the network. We probably want to always find the Pi
at the same address, however, so a static IP makes more sense than one
that the router dynamically assigns.&lt;/p&gt;
&lt;p&gt;To find the list of static IP's on my specific router, I clicked on
the link entitled &lt;strong&gt;Network&lt;/strong&gt; in my router's configuration page. The
relevant information for me looks like that in the image below:&lt;/p&gt;
&lt;img alt="DHCP address pool" class="align-center" src="http://kmdouglass.github.io/images/dhcp_addresses.png"&gt;
&lt;p&gt;This information is telling us that the router is reserving addresses
192.168.0.10 to 192.168.0.254 for the DHCP server. We can therefore
most probably use 192.168.0.2 through 9 for static IP's. (Remember
that 192.168.0.1 is already taken; it's the address of the router.) I
tested 192.168.0.2 by pinging it and received no response, so we will
use this address for my Raspberry Pi. (Use Ctrl-C to stop pinging the
device.):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
kmdouglass@kmd-laptop:~$ ping 192.168.0.2
PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.
From 192.168.0.15 icmp_seq=1 Destination Host Unreachable
From 192.168.0.15 icmp_seq=2 Destination Host Unreachable
From 192.168.0.15 icmp_seq=3 Destination Host Unreachable
^C
--- 192.168.0.2 ping statistics ---
4 packets transmitted, 0 received, +3 errors, 100% packet loss, time 3014ms
pipe 3
&lt;/pre&gt;
&lt;p&gt;For the next step, we need to collect the broadcast and subnet mask of
the network. We can do this from the laptop that is already connected
to the network by running the &lt;code&gt;sudo ifconfig&lt;/code&gt; command. This
command will report information that looks similar to the following
example (note that this is not from my machine but is merely for
illustration)::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
eth0 Link encap:Ethernet HWaddr 00:10:5A:1A:DC:65
inet addr:198.209.253.169 Bcast:208.141.109.255 Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:18940 errors:1 dropped:0 overruns:0 frame:2
TX packets:11554 errors:0 dropped:0 overruns:0 carrier:0
collisions:2 txqueuelen:100
RX bytes:4087250 (3.8 Mb) TX bytes:2499423 (2.3 Mb)
Interrupt:11 Base address:0xd000
&lt;/pre&gt;
&lt;p&gt;The very first line tells us that this block of output belongs to the
&lt;strong&gt;eth0&lt;/strong&gt; interface. If you connect to the internet on your laptop
through WiFi, then you may need to find the information for the
&lt;strong&gt;wlan0&lt;/strong&gt; interface instead. wlan0 is usually used to refer to
wireless interfaces in Ubuntu and Debian Linux.&lt;/p&gt;
&lt;p&gt;The first line of output from ifconfig also provides the type of
hardware and the ID of the ethernet card. The information we need,
however, is on the second line. The device's IP address on the network
is &lt;strong&gt;inet addr:198.209.253.169&lt;/strong&gt;, but we don't really need this
information. Rather, we need the two numbers that come next. The
broadcast IP is reported in &lt;strong&gt;Bcast:208.141.109.255&lt;/strong&gt; and the subnet
mask in &lt;strong&gt;Mask:255.255.255.0&lt;/strong&gt;. The &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Broadcast_address"&gt;broadcast IP&lt;/a&gt; is used to send
messages to all devices on the network, whereas the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Subnetwork"&gt;subnet mask&lt;/a&gt; is
used to separate the parts of an address that identify the network
from the parts that identify the devices and possible "sub-networks."&lt;/p&gt;
&lt;p&gt;To summarize this section, we need:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The static IP address that we'll assign to the Pi&lt;/li&gt;
&lt;li&gt;The IP address of the router, i.e. the gateway address&lt;/li&gt;
&lt;li&gt;The broadcast IP&lt;/li&gt;
&lt;li&gt;The subnet mask&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-pi"&gt;
&lt;h2&gt;Configure the Pi&lt;/h2&gt;
&lt;p&gt;Now that we have decided on an IP address for the Pi, let's boot it up
and configure it to always use this IP address. (I am currently using
the &lt;strong&gt;NOOBS&lt;/strong&gt; operating system that came with my Pi starter kit, but
this should work with other flavors of Debian Linux as well.)&lt;/p&gt;
&lt;p&gt;Once logged on to the Pi, open a terminal and make a backup copy of
the file &lt;strong&gt;/etc/network/interfaces&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo cp /etc/network/interfaces /etc/network/interfaces.bak
&lt;/pre&gt;
&lt;p&gt;Making a backup is good practice; in case we ruin the configuration
file, we can simply rewrite it using our backup. Next, open the
original &lt;strong&gt;interfaces&lt;/strong&gt; file for editing. In this example, I'll use
the &lt;strong&gt;nano&lt;/strong&gt; editor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo nano /etc/network/interfaces
&lt;/pre&gt;
&lt;p&gt;In this file, add the following lines (replacing the addresses with
those appropriate for your network):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
auto eth0
iface eth0 inet static
    address 192.168.0.2
    netmask 255.255.255.0
    gateway 192.168.0.1
    broadcast 192.168.0.255
&lt;/pre&gt;
&lt;p&gt;What do these lines do, you ask? Let's step through them one-by-one.&lt;/p&gt;
&lt;div class="section" id="start-the-network-interface-at-boot"&gt;
&lt;h3&gt;Start the network interface at boot&lt;/h3&gt;
&lt;p&gt;First off, we need to identify the network interface. &lt;strong&gt;eth0&lt;/strong&gt; is the
identifier that is referring to the dedicated ethernet port on the
Pi. The line &lt;strong&gt;auto eth0&lt;/strong&gt; means that this interface will be started
at boot.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="configure-the-interface-to-use-a-static-ip"&gt;
&lt;h3&gt;Configure the interface to use a static IP&lt;/h3&gt;
&lt;p&gt;Next, we see the line &lt;strong&gt;iface eth0 inet static&lt;/strong&gt;. First, &lt;strong&gt;iface
eth0&lt;/strong&gt; means that we are configuring the ethernet port interface that
was described in the last section. Following that, &lt;strong&gt;inet&lt;/strong&gt; specifies
that the interface uses TCP/IP networking. Finally, &lt;strong&gt;static&lt;/strong&gt; is
telling the NOOBS operating system that the device is going to request
a static IP address from the router. (I obtained this explanation from
&lt;a class="reference external" href="http://askubuntu.com/questions/411616/what-does-keywords-in-my-etc-network-interfaces-means"&gt;this forum post&lt;/a&gt;.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="set-the-various-addresses"&gt;
&lt;h3&gt;Set the various addresses&lt;/h3&gt;
&lt;p&gt;The next lines are indented because they are properties of the &lt;strong&gt;inet
static&lt;/strong&gt; family. If you've read everything until now, you should be
able to figure out what addresses to enter next for each option. The
desired static IP address for the Pi should follow the &lt;strong&gt;address&lt;/strong&gt;
field; the subnet mask, gateway, and broadcast IP's described above
should follow &lt;strong&gt;netmask&lt;/strong&gt;, &lt;strong&gt;gateway&lt;/strong&gt;, and &lt;strong&gt;broadcast&lt;/strong&gt;
respectively.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;network&lt;/strong&gt; property (which is not shown above) contains the
network address and &lt;a class="reference external" href="http://man.cx/interfaces%285%29"&gt;is required for 2.0.x kernels&lt;/a&gt;. These kernels
are pretty old by now, so it is unlikely that you will need to specify
this property.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="restart-the-network-interface"&gt;
&lt;h3&gt;Restart the network interface&lt;/h3&gt;
&lt;p&gt;Restarting the interface we just configured on our Pi is as simple
as entering these terminal commands:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ifdown eth0
sudo ifup eth0
&lt;/pre&gt;
&lt;p&gt;(Remember to replace eth0 with the appropriate interface if yours is
different.) If everything goes well, we should be able to use our web
browser to navigate on the Internet. We should also be able to ping
the Pi from the laptop and vice versa.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="connecting-to-the-pi"&gt;
&lt;h2&gt;Connecting to the Pi&lt;/h2&gt;
&lt;p&gt;Once the Pi is on the network, we need a way to connect to it from the
laptop and other devices so that we can actually use it for
something. One way is to use &lt;a class="reference external" href="https://support.suso.com/supki/SSH_Tutorial_for_Linux"&gt;ssh&lt;/a&gt;, or Secure SHell. ssh is program
that let's us securely log on to other devices through a shell
(i.e. terminal). This is useful for when we need to work only on the
command line.&lt;/p&gt;
&lt;p&gt;If, on the other hand, we want a "Remote Desktop"-like GUI
environment, we can use &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;VNC&lt;/a&gt;. The documentation for VNC is quite
good but detailed; I'll let you read up on it on your own if you're
interested in using it.&lt;/p&gt;
&lt;p&gt;I'll now briefly explain how we can set up ssh on the Pi.&lt;/p&gt;
&lt;div class="section" id="edit-vnc-installation"&gt;
&lt;h3&gt;EDIT: VNC installation&lt;/h3&gt;
&lt;p&gt;As it turns out, you may run into some problems if you do try to setup
VNC by following the documentation in the link above. Namely, the
documentation is missing a key step, at least for me. I had to first
install the VNC server software on the Pi via:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get update
sudo apt-get install realvnc-vnc-server
&lt;/pre&gt;
&lt;p&gt;Even though the rest of this post is about ssh, you may still find
this information useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="enable-ssh-on-the-pi"&gt;
&lt;h3&gt;Enable ssh on the Pi&lt;/h3&gt;
&lt;p&gt;We need to enable ssh access to the Pi before we can use it. On the
Pi, open a terminal and run the configuration utility::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo raspi-config
&lt;/pre&gt;
&lt;p&gt;We should see the following window appear.&lt;/p&gt;
&lt;img alt="The raspi-config menu with Interface Options highlighted." class="align-center" src="http://kmdouglass.github.io/images/pi-config-interface-options.png"&gt;
&lt;p&gt;Use the keyboard to highlight &lt;strong&gt;Interface Options&lt;/strong&gt; and tap the Enter
key. In the following menu, we now should see an option to enable ssh
as in the following image. Use the keyboard to highlight &lt;strong&gt;P2 SSH&lt;/strong&gt;
(or the relevant menu item if the name is different on your Pi) and
hit the Enter key to enable it. Once ssh is enabled, we can hit Esc or
select the &amp;lt;Back&amp;gt; option to until we exit the configuration utility.&lt;/p&gt;
&lt;img alt="The raspi-config Interface Options menu with P2 SSH highlighted." class="align-center" src="http://kmdouglass.github.io/images/pi-config-ssh.png"&gt;
&lt;p&gt;If you'e following along, you may need to restart your Pi for these
changes to take effect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="log-onto-the-pi-from-the-laptop"&gt;
&lt;h3&gt;Log onto the Pi from the laptop&lt;/h3&gt;
&lt;p&gt;Now for the moment of truth. After restarting the Pi, &lt;strong&gt;we need to
first ensure that we are not logged in to it&lt;/strong&gt;. If we are, simply
click the &lt;strong&gt;Menu&lt;/strong&gt; button, followed by &lt;strong&gt;Shutdown... -&amp;gt; Logout&lt;/strong&gt; and
log out of the session.&lt;/p&gt;
&lt;p&gt;Next, open a terminal on the laptop and enter the following command,
changing the IP address to whatever was decided upon for the Pi::&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ssh pi@192.168.0.2
&lt;/pre&gt;
&lt;p&gt;This command runs the ssh program and asks to sign into the Pi as the
user called &lt;strong&gt;pi&lt;/strong&gt;. After running the command, we may be prompted for
a password to log on if one was set on the Pi. (You did set one,
didn't you?) Once successfully entering the password, we should notice
that the terminal prompt has changed to something like
&lt;code&gt;pi@raspberrypi:~ $&lt;/code&gt;. This indicates that we are logged on to
the Pi. If we enter the &lt;code&gt;ls&lt;/code&gt; command, we should see the contents
of the Pi's home directory. When we're ready to disconnect from the
Pi, we can simply use the &lt;code&gt;exit&lt;/code&gt; command at any time in the
terminal. The prompt should change to reflect that we are back on our
laptop machine when we have successfully exited.&lt;/p&gt;
&lt;p&gt;If this is all working as described above, then congratulations on
connecting your Pi to your home Linux network! I wish you many happy
hours of hacking :)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="further-reading"&gt;
&lt;h2&gt;Further Reading&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The Debian network setup manual is very detailed and describes
many, many more aspects of setting up a network than I touched upon
here. &lt;a class="reference external" href="https://www.debian.org/doc/manuals/debian-reference/ch05.en.html"&gt;https://www.debian.org/doc/manuals/debian-reference/ch05.en.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Raspberry Pi documentation about VNC (Virtual Network
Computing) is a great resource for setting up a graphical interface
to remotely connect to your
Pi. &lt;a class="reference external" href="https://www.raspberrypi.org/documentation/remote-access/vnc/"&gt;https://www.raspberrypi.org/documentation/remote-access/vnc/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>linux</category><category>raspberry pi</category><guid>http://kmdouglass.github.io/posts/connecting-a-raspberry-pi-to-a-home-linux-network/</guid><pubDate>Sun, 05 Feb 2017 09:28:17 GMT</pubDate></item></channel></rss>