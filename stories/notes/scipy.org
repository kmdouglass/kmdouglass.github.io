#+BEGIN_COMMENT
.. title: Scientific Python Notes
.. slug: scipy
.. date: 1/14/2015
.. tags: python
.. link:
.. description: Notes on using Python tools for scientific applications.
.. type: text
#+END_COMMENT
#+OPTIONS: toc:nil num:t ^:nil
#+TOC: headlines 3

* matplotlib

** Removing parts of the frame
   Some journals disallow having the right and top lines outlining a
   plot. For these situations, you can remove them by using methods
   associated to the /spines/ field of your axis object.

   #+BEGIN_SRC python
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
   #+END_SRC

-----

** Changing the frame linewidth
   Changing the frame linewidth is achieved by the /set_linewidth/
   method of an axes /spine/ field.

   #+BEGIN_SRC python
ax.spines['left'].set_linewidth(0.5)
ax.spines['bottom'].set_linewidth(0.5)
   #+END_SRC

-----

** Remove the legend frame
   #+BEGIN_SRC python
import matplotlib.pyplot as plt
leg = plt.legend()
leg.draw_frame(False)
   #+END_SRC

-----
** Tight layout (fixing clipped axes titles)
   For small figures like those which may go in publications, the axes
   titles and labels may fall outside of the figure boundary and
   therefore appear clipped.

   To fix this, matplotlib provides a function called *tight_layout()*
   which automatically moves a subplot to fix the plot within the
   figure. It also fixes overlapping axis titles in figures with
   multiple subplots.

   *tight_layouts()* is provided as a method instance of a Figure
   object, or through *pyplot*.

   #+BEGIN_SRC python
plt.tight_layout()
   #+END_SRC

   Sometimes, the default settings of *tight_layout* still do not fix
   the clipping. In this case, I can adjust its pad, w_pad, or h_pad
   arguments to adjust the amount of padding introduced by the
   method. The numeric amounts are fractions of the font size. *pad*
   adds padding to the subplots and the figure border, whereas *w_pad*
   and *h_pad* add padding between individual subplots.

-----

** Changing matplotlib font families and size
   The fonts in figures can be changed with a little help with
   matplotlib's *font_manager*.

   The following snippet changes the font family to Arial and the size
   to 12pt using the font_manager to find the proper name of the
   font. (Using font_manager isn't necessary if you know the name
   already.)

   #+BEGIN_SRC python
import matplotlib.font_manager as font_manager
from matplotlib import rcParams

fontpath = '/usr/share/fonts/truetype/msttcorefonts/Arial.ttf'
prop = font_manager.FontProperties(fname = fontpath)
rcParams['font.family'] = prop.get_name()
rcParams.update({'font.size' : 12})
   #+END_SRC

-----   

*** Clear the matplotlib font cache
    It is very important to clear the matplotlib font list cache after
    adding new fonts to the system. Otherwise, matplotlib will not be
    able to find your font.

    Many forums suggest that this cache is named *fontList.cache* and
    is located at *~/.config/matplotlib/*. However, this /is not/ the
    location where my cache file is stored, nor is it the name of the
    file.

    After adding new fonts, I should run the commands

    #+BEGIN_SRC sh
rm -i ~/.cache/matplotlib/fontList.py3k.cache
rm -ri ~/.cache/matplotlib/tex.cache
    #+END_SRC

-----

* Installing and working with multiple versions of Python
I sometimes run into problems if I install multiple versions of Python
on the same system. This is largely because my operating system
depends on a specific version of Python and its libraries, and these
can be corrupted if other versions are installed. In addition, I often
want different packages and versions for different projects.

To avoid these issues, I started building Python from source and
installing the binaries in a separate folder. I then use a virtualenv
that points to these binaries. This keeps all my Python packages and
binaries completely separate from the system-level Python install.

-----

** Building Python and installing binaries to a non-default location
   It's easy to install the Python binaries to a custom directory by
   setting the --prefix and --exec-prefix flags when running the
   configure script:

   #+BEGIN_SRC sh
./configure --prefix=~/src/Python3.4.2 --exec-prefix=~/src/Python3.4.2
   #+END_SRC

   After running this command, make, and make install, the binaries
   and libraries will be placed in these directories instead.

-----

** Setting the interpreter in a virtualenv
   After setting up virtualenv and virtualenv wrapper, I can create a
   new virtual environment that use these binaries with the /-p/ flag
   in the mkvirtualenv command:

   #+BEGIN_SRC sh
mkvirtualenv -p ~/Python3.4.2/bin/python3.4 MY_VENV_NAME
   #+END_SRC
-----

** Required system packages for optional Python features
   The following Debian system packages (I am using Jessie now) are
   required to build Python with some of its optional features:
   + Tkinter :: tk-dev and possibly python3-tk
   + dbm :: libgdbm-dev
-----

* Installing Spyder inside a virtuanlenv
Spyder is a pretty good Python IDE for scientific applications. It
mimics Matlab's IDE functionality, which, to be honest, is really
great even considering the annoying things about the Matlab language.

Unfortunately, Spyder takes little bit of effort to work with
virtualenvs.
-----

** Install SIP and PyQt4 inside the virtualenv
The primary difficulty with installing Spyder in a virtualenv is not
Spyder itself, but two of its prerequisites: SIP and PyQt4.

[[http://amyboyle.ninja/Python-Qt-and-virtualenv-in-linux/][Fortunately, there is a relatively painless way]] to build SIP and PyQt4
for every virtualenv that you want to use Spyder with.

First, make sure you have the required libraries installed:

#+BEGIN_SRC sh
sudo apt-get install python2.7-dev libxext-dev qt4-dev-tools build-essential
#+END_SRC

Next, download the SIP and PyQt4 Linux source tarballs and unzip them
into separate directories. *Enable your virtualenv using* =workon
MY_VIRTUALENV=, enter the SIP directory, and type =python
config.py=. When it's done you should see that SIP will be installed
to your virtualenv's directory, not your site directory. Finish the
SIP installation with =make= and =sudo make install=.

After this, move inside the PyQt4 source directory. Configure the Make
file with

#+BEGIN_SRC sh
python configure-ng.py -q /usr/bin/qmake-qt4
#+END_SRC

Follow this with another =make= and =sudo make install=.
-----

** Install Spyder
Once SIP and PyQt4 are installed, it's really easy to install Spyder:

#+BEGIN_SRC
pip install spyder
#+END_SRC

Its executable is stored in
/venv_directories/my_virtualenv/bin/spyder3 (if you're using
Python3). Note that you need to build PyQt4 every time you want to
install Spyder inside a different virtualenv.
