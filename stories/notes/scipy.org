#+BEGIN_COMMENT
.. title: Scientific Python Notes
.. slug: scipy
.. date: 1/14/2015
.. tags: python
.. link:
.. description: Notes on using Python tools for scientific applications.
.. type: text
#+END_COMMENT
#+OPTIONS: toc:nil num:t ^:nil
#+TOC: headlines 3

* matplotlib

** Removing parts of the frame
   Some journals disallow having the right and top lines outlining a
   plot. For these situations, you can remove them by using methods
   associated to the /spines/ field of your axis object.

   #+BEGIN_SRC python
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
   #+END_SRC

   To remove the tick marks, use

   #+BEGIN_SRC
ax.xaxis.set_ticks_position('bottom')
ax.yaxis.set_ticks_position('left')
   #+END_SRC

-----

** Changing the frame linewidth
   Changing the frame linewidth is achieved by the /set_linewidth/
   method of an axes /spine/ field.

   #+BEGIN_SRC python
ax.spines['left'].set_linewidth(0.5)
ax.spines['bottom'].set_linewidth(0.5)
   #+END_SRC

-----

** Remove the legend frame
   #+BEGIN_SRC python
import matplotlib.pyplot as plt
leg = plt.legend()
leg.draw_frame(False)
   #+END_SRC

-----
** Tight layout (fixing clipped axes titles)
   For small figures like those which may go in publications, the axes
   titles and labels may fall outside of the figure boundary and
   therefore appear clipped.

   To fix this, matplotlib provides a function called *tight_layout()*
   which automatically moves a subplot to fix the plot within the
   figure. It also fixes overlapping axis titles in figures with
   multiple subplots.

   *tight_layouts()* is provided as a method instance of a Figure
   object, or through *pyplot*.

   #+BEGIN_SRC python
plt.tight_layout()
   #+END_SRC

   Sometimes, the default settings of *tight_layout* still do not fix
   the clipping. In this case, I can adjust its pad, w_pad, or h_pad
   arguments to adjust the amount of padding introduced by the
   method. The numeric amounts are fractions of the font size. *pad*
   adds padding to the subplots and the figure border, whereas *w_pad*
   and *h_pad* add padding between individual subplots.

-----
** Tight layout (setting subplot bounding box)
   I once created a figure with a single legend but four subplots
   arranged in a two-by-two manner. I wanted the legend to sit above
   all the plots but not cover any of their content.

   The way I did this was to set the legend location relative to the
   figure bounding box and then squeeze the subplots into a smaller
   bounding box below the legend so that everything fit inside the
   figure.

   #+BEGIN_SRC python
# Place legend above subplots
plt.legend(bbox_to_anchor=(0.65, 1),
           bbox_transform=plt.gcf().transFigure)

# Squeeze subplots into a smaller bounding box, relative to the figure
plt.tight_layout(rect = [0, 0, 1, 0.9])
   #+END_SRC

   All units here are in normalized figure units. I placed the legend
   at the top center(ish) of the bounding box with the parameter
   *bbox_to_anchor=(0.65,1)*.

   Next,the whole bounding box was resized using *tight_layout*. By
   default, the *rect* parameter is set to *[0, 0, 1, 1]*, which means
   it extends from (0,0) in the bottom left corner of the figure to
   (1,1) in the upper right corner.

-----

** Changing matplotlib font families and size
   The fonts in figures can be changed with a little help with
   matplotlib's *font_manager*.

   The following snippet changes the font family to Arial and the size
   to 12pt using the font_manager to find the proper name of the
   font. (Using font_manager isn't necessary if you know the name
   already.)

   #+BEGIN_SRC python
import matplotlib.font_manager as font_manager
from matplotlib import rcParams

fontpath = '/usr/share/fonts/truetype/msttcorefonts/Arial.ttf'
prop = font_manager.FontProperties(fname = fontpath)
rcParams['font.family'] = prop.get_name()
rcParams.update({'font.size' : 12})
   #+END_SRC

-----   

*** Clear the matplotlib font cache
    It is very important to clear the matplotlib font list cache after
    adding new fonts to the system. Otherwise, matplotlib will not be
    able to find your font.

    Many forums suggest that this cache is named *fontList.cache* and
    is located at *~/.config/matplotlib/*. However, this /is not/ the
    location where my cache file is stored, nor is it the name of the
    file.

    After adding new fonts, I should run the commands

    #+BEGIN_SRC sh
rm -i ~/.cache/matplotlib/fontList.py3k.cache
rm -ri ~/.cache/matplotlib/tex.cache
    #+END_SRC

-----

* IPython

** Creating different Notebook profiles
   I sometimes make publication figures using the [[http://ipython.org/notebook.html][IPython Notebook]]. At
   other times, I use it simply as a means of doing data
   analyses. Regardless, I have different purposes for using it, and
   this means I often want it to behave differently depending on its
   current purpose.

   An easy way to set IPython's configuration settings and have it
   remember specific ones is to make different profiles for it to use.

   To make a new profile, run this command in the terminal:

   #+BEGIN_SRC sh
ipython profile create myProfile
   #+END_SRC
   
   This will create a profile called myProfile. The configuration
   settings are stored in ~/.ipython/profile_myProfile/. Importantly,
   to change the Notebook's behavior, change the settings in
   *ipython_notebook_config.py*.

   To use this profile, start the notebook with the command

   #+BEGIN_SRC sh
ipython notebook --profile=myProfile
   #+END_SRC
